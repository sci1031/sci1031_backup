
# Données vectorielles {#vec}


Cette leçon est une introduction aux données spatiales vectorielles sous `R`. L'objectif principal de ce module est d'apprendre à créer, lire, interpréter et visualiser des données vectorielles^[Le matériel pour ce cours est tiré du chapitre sur les données vectorielles du manuel [Geocomputation with R](https://bookdown.org/robinlovelace/geocompr/spatial-class.html) [@lovelace_geocomputation_2021] et du cours *Introduction to Geospatial Raster and Vector Data with R* [@Data_Carpentry_IntroGeospatial] de l’organisme [Data Carpentry](https://datacarpentry.org/). Data Carpentry développe et offre des formations variées et spécialisées sur le traitement et l’analyse de données. Ses formations s’adressent surtout aux chercheuses et chercheurs scientifiques, mais peuvent être consultées par quiconque car leur matériel est libre d’accès. N’hésitez donc pas à y jeter un coup d’œil.]. 

La section [4.1](#create_vec) expliquera comment créer des données vectorielles. Les sections [4.2-4.4](#read_vec)
porteront sur des données vectorielles en format *shapefile* puisque celles-ci sont couramment utilisées.
La section [4.5](#gdb) vous familiarisera avec les données vectorielles en format *geodatabase* puisque celles-ci sont de plus en plus utilisées au sein de grandes organisations comme des ministères. 


<br>


###### À la fin de ce module vous saurez: {-}

---


 - Créer des données vectorielles et comprendre leur structure.
 - Lire un *shapefile*, explorer ses métadonnées et interpréter sa géométrie.
 - Lire une *geodatabase*, et explorer ses couches.
 - Visualiser des données vectorielles de type point, ligne et polygone.
 - Visualiser des données vectorielles par attribut.
 - Visualiser plusieurs données vectorielles au sein d'une même figure.
 - Transformer le système de coordonnées de référence de données vectorielles.

---

<br>

<div class="boite ico librairie gauche">
###### Vous utiliserez les bibliothèques suivantes: {-}

- `sf`
- `rgdal`
- `mapview`
- `leafsync`
- `spData`

Installez ces librairies si vous ne les avez pas:
```{r, eval = FALSE}
install.packages(c('sf', 'rgdal', 'mapview', 'leafsync', 'spData'))
```

</div>

<br>

<div class="boite ico fonctions gauche">
###### Vous apprendrez à utiliser les fonctions suivantes: {-}

- `st_point()`, `st_multipoint()`
- `st_linestring()`, `st_multilinestring()`
- `st_polygon()`, `st_multipolygon()`
- `st_sfc()`
- `st_sf()`
- `st_as_sf()`
- `st_read()`
- `st_write()`
- `st_geometry_type()`
- `st_crs()`
- `st_bbox()`
- `mapview()`
- `st_transform()`
- `latticeView()`
- `as.factor()`
- `levels()`
- `class()`

</div>

<div class="boite ico donnees gauche">
###### Vous utiliserez les données suivantes: {-}

Dans la section [leçon](#lecon_vec), vous utiliserez deux ensembles de données vectorielles. 

Le premier ensemble contient des données *shapefile* relatives au réseau de pistes cyclables de la ville de Montréal et aux accidents routiers impliquant des bicyclettes.

Le second ensemble constitue une *géodatabase* contenant des données du Ministère de l'Éducation et de l'Enseignement Supérieur du Québec relatives aux établissements d'enseignement sur le territoire québécois.

Dans la section [exercice](#ex_vec), vous utiliserez les données vectorielles `nz` disponibles dans la bibliothèque `spData`.

</div>

```{r load-libraries4, echo = FALSE, results='hide', warning = FALSE, message = FALSE}
#library(raster)
library(rgdal)
library(sf)
library(mapview)
library(leafsync)
```


## Leçon {#lecon_vec}


### Télécharger les données {#data_mod4}

<div class="boite ico donnees gauche"> 

###### Les données {-} 

<br>

</div>

Dans les sections [4.1.3](#read_vec) à [4.1.6](#gdb) du présent module vous apprendrez à lire et visualiser des données déjà existantes. Afin de faciliter le téléchargement de ces multiples données, l'ensemble des couches d'informations spatiales peuvent être téléchargées en cliquant sur un seul lien: [données pour le module 4](https://github.com/sci1031/data/raw/master/Module4_donnees.zip). Sauvegardez le dossier compressé (`zip`) dans votre répertoire de travail `Module4_donnees` pour ce module, et dézippez-le. Le dossier comprend lui même deux dossiers compressés et un fichier `csv`: 

- `Montreal_Velo.zip`
- `Donnees_Ouvertes_MEES.gbd.zip`
- `nz_capitales.csv`


Dézipper chacun des deux dossiers. Le premier dossier, `Montreal_Velo` sera utilisé aux sections [4.1.3-4.1.5](#read_vec). Il contient les données vectorielles relatives au réseau de pistes cyclables de la ville de Montréal et aux accidents routiers impliquant des bicyclettes. Il contient trois sous-dossiers: 

- `accidents`
- `pistes`
- `terre`.

Le deuxième dossier, `Donnees_Ouvertes_MEES.gbd` est la geodatabase du Ministère de l'Éducation et de l'Enseignement Supérieur du Québec (MEES); nous l'utiliserons à la section [4.1.6](#gdb).

Le fichier `nz_capitales.csv` contient les coordonnées géographiques des capitales des régions administratives de la Nouvelle-Zélande; nous l'utiliserons à la section [exercices](#ex_vec) à la fin de ce module. 



### Créer des données vectorielles {#create_vec}

Pour créer, lire et manipuler des données vectorielles, nous allons utiliser la bibliothèque `sf`. Notez que la bibliothèque `rgdal` se charge automatiquement lorsque `sf` se charge.

```{r load-sf, eval = FALSE}
library(sf)
```
<br>


#### Créer des géométries simples {-}

Nous avons appris à la [leçon 2](#base) que les données vectorielles peuvent avoir différentes géométries (point, ligne, polygone, etc.). La bibliothèque `sf` possède des fonctions pour créer ces géométries simples, c'est-à-dire pour créer des objects de la classe `sfg` (pour **simple feature geometry**).

La fonction `st_point()` permet de transformer un vecteur numérique représentant les coordonnées d'un point en un objet de type **point**. Par exemple,

```{r}
p <- c(3,5)
point <- st_point(p)
point
```
<br>

Remarquez que la classe de l'objet formé est `sfg`:
```{r}
class(point)
```
<br>

La fonction `st_multipoint()` permet de créer une géométrie **multipoint**. Nous devons fournir à cette fonction une matrice où chaque rangée définie les coordonnées d'un des points:

```{r}
M <- rbind( c(3,5), c(5,5), c(4,1), c(2,3))
multi_point <- st_multipoint(M)
multi_point
```
<br>

La fonction `st_linestring()` permet de créer une **ligne**. Nous devons également lui fournir une matrice contenant les coordonnées des extrémités de la ligne. 

```{r}
ligne <- st_linestring(M)
ligne
```
<br>

Un **polygone** se crée de façon similaire, cette fois en utilisant la fonction `st_polygon()`. Les coordonnées des extrémités du polygone doivent toutefois être définies dans une liste, et non une matrice. Il s'agit alors d'utiliser la fonction `list()` pour convertir une matrice en liste. 

```{r}
L <- list(rbind( c(3,5), c(5,5), c(4,1), c(2,3), c(3,5)))
polygone <-st_polygon(L)
polygone
```
<br>

Noter que pour créer un polygone la première extrémité doit être identique à la dernière. 
<br>

```{r plotgeo, eval = TRUE, echo = FALSE, fig.height=5, fig.show='hold',fig.align='center', dev = 'png', fig.cap = "Géométries multipoint, ligne et polygone crées avec les fonctions `st_multipoint()`,`st_linestring()`, et `st_polygon()` respectivement."}

m_multi_point <- mapview(multi_point)
m_ligne <- mapview(ligne)
m_polygone <-mapview(polygone)
leafsync::latticeView(m_multi_point, m_ligne, m_polygone, ncol=3)
```

```{r plotgeo2, eval = FALSE, echo = FALSE, dev = 'png', fig.cap = "Géométries multipoint, ligne et polygone crées avec les fonctions `st_multipoint()`,`st_linestring()`, et `st_polygon()` respectivement."}
M_df <- as.data.frame(M)
M_points <- st_as_sf(M_df, coords = c("x","y"))
ligne <- st_linestring(M)
ligne

```





<br>

Dans un même ordre d'idées, pour créer des **multi-lignes** ou des **multi-polygones** nous devons aussi recourrir à des listes où chaque élément de la liste correspond à une ligne ou à un polygone respectivement. 

```{r}
M1 <- rbind( c(3,5), c(5,5), c(4,1), c(2,3))
M2 <- rbind( c(1,2), c(2,2), c(2,1))
L  <- list(M1, M2)
multi_ligne <- st_multilinestring(L)
multi_ligne
```
<br>

```{r}
L1 <- list(rbind( c(3,5), c(5,5), c(4,1), c(2,3), c(3,5)))
L2 <- list(rbind( c(1,2), c(2,2), c(2,1), c(1,2)))
L  <- list(L1, L2)
multi_polygone <- st_multipolygon(L)
multi_polygone
```
<br>


#### Attribuer un SCR {-}

Nous venons d'apprendre les fonctions de base de la bibliothèque `sf` pour créer des géométries simples. Or, les données vectorielles ne sont pas uniquement des géométries, ce sont des géométries géoréférencées. Ceci signifie qu'on doit attribuer aux géométries un datum et une projection. Pour ce faire, nous devons créer des objets de la classe `sfc`, c'est-à-dire **simple feature columns**. 

Un objet `sfc` est une liste d'objets `sfg` qui permet, en plus, de contenir l'information relative au système de coordonnées de référence (SRC) utilisé. 

La fonction `st_sfc()` permet de transformer un objet de classe `sfg` en un objet de classe `sfc`. Par exemple, transformons le point créer plus haut:

```{r}
point_sfc <- st_sfc(point)
```
<br>


Alors que l'objet `point` contenait seulement la géométrie de l'objet:
```{r}
point
```
<br>

L'objet `point_sfc` contient la géométrie de l'objet et il possède la structure pour définir le SCR (CRS en anglais), bien que pour l'instant ce dernier ne soit pas défini (valeur de NA):

```{r}
point_sfc
```
<br>

La fonction `st_sfc()` peut être utilisée sur les autres géométries. Elle permet également de combiner des géométries. Par exemple:

```{r}
L1 <- list(rbind( c(3,5), c(5,5), c(4,1), c(2,3), c(3,5)))
polygone1 <- st_polygon(L1)
L2 <- list(rbind( c(1,2), c(2,2), c(2,1), c(1,2)))
polygone2 <- st_polygon(L2)
polygone_sfc <- st_sfc(polygone1, polygone2)
polygone_sfc
```
<br>

Pour connaître le SCR d'un object vectoriel, il s'agit d'utiliser la fonction `st_crs()` de la bibliothèque `st`:
```{r}
st_crs(polygone_sfc)
```
<br>

Dans le cas présent, le SCR est indéfini.

Il existe plusieurs façons de définir le SCR. La façon la plus simple est d'utiliser le code [EPSG](#code_epsg) associé au SCR que l'on désire utilisé. Par exemple, utilisons le EPSG 32198 correspondant au système de coordonnées *conique conforme de Lambert* dans le datum NAD83 pour définir le CRS de `polygone_sfc`:

```{r,  attr.output='style="max-height: 200px;"'}
polygone_sfc <- st_sfc(polygone1, polygone2, crs = 32198)
st_crs(polygone_sfc)
```

<br>

Nous pouvons également utilisé la notation `proj4string`:
```{r}
st_crs(polygone_sfc)$proj4string
```
<br>

```{r}
st_sfc(point, crs = "+proj=lcc +lat_0=44 +lon_0=-68.5 
                               +lat_1=60 +lat_2=46 
                               +x_0=0 +y_0=0 +datum=NAD83 
                               +units=m +no_defs")
```
<br>

Ou encore référé au SCR d'un autre objet:

```{r}
st_sfc(point, crs = st_crs(polygone_sfc))
```
<br>

#### Définir des attributs {-}

Les attributs sont les variables non-géographiques permettant de décrire les données vectorielles. Les attributs peuvent, par exemple, correspondre au nom de chaque objet ou à d'autres caractéristiques qualitatives ou numériques.

Les attributs sont répertoriés dans un objet de classe `data.frame`, qui est en quelque sorte une matrice dont les colonnes peuvent accueillir des données de différents types (numérique, charactère, logique, facteur, etc.).

Afin de démontrer comment joindre des attibuts à des géométries géoréférencées, créons d'abord un objet `sfc` constitué de quatre points.
```{r}
# Créer quatre vecteurs numériques
p1 <- c(3,5)
p2 <- c(5,5)
p3 <- c(4,1)
p4 <- c(2,3)
# Créer des géométries de type point
point1 <- st_point(p1)
point2 <- st_point(p2)
point3 <- st_point(p3)
point4 <- st_point(p4)
# Créer un simple feature column 
# et attribuer un SRC
points_sfc <- st_sfc(point1,point2,point3,point4, crs = 32198)
points_sfc
```
<br>

Supposons que les points désignent des écoles primaires pouvant être publiques ou privées. Utilisons la fonction `data.frame()`, une fonction de base de `R` pour créer une table des attributs. 
```{r}
points_attribut <- data.frame(
  nom = c("École A", "École B", "École C", "École D"),
  nombre_eleves = c(403, 357, 280, 296),
  ecole_publique = as.logical(1, 1, 0, 1)
)
points_attribut
```
<br>

Remarquer que chaque colonne est associée à un attribut de classe différente, comme le permet la classe `data.frame`.

Pour associer cette table d'attributs à l'objet `points_sfc`, il s'agit d'utiliser la fonction `st_sf()` de la bilbiothèque `sf`:
```{r}
points_sf <- st_sf(points_sfc, points_attribut)
points_sf
```
<br>

L'objet `points_sf` résultant de cette opération contient deux classes:
```{r}
class(points_sf)
```
La composante de classe `sf` (pour **simple feature**) contient les attributs spatiaux des données tandis que la composante de classe `data.frame` contient les attributs non-spatiaux. 

<!-- icone attention  -->
Cette dualité est une caractéristique importante des objets de classe `sf`: ceux-ci sont essentiellement des `data.frames` avec une extension spatiale et nous pouvons ainsi les manipuler comme des `data.frames`. Nous reviendrons sur ce concept au [Module 7](#manip_vec) portant sur la manipulation de données vectorielles.


<br>

#### La fonction `st_as_sf()` {.unnumbered #fct_st_as_sf}

La fonction `st_as_sf()` de la bibliothèque `sf` permet de créer un objet de classe `sf` à partir d'un objet d'une autre classe. En particulier, elle permet de convertir en un objet `sf` de type points un `data.frame` qui contient des colonnes donnant les coordonnées de chaque élément. 

Donnons un exemple. Considérons le tableau suivant:

```{r}
point_df <- data.frame(
  points = c("alpha" ,"beta" ,"gamma", "delta"),
  x = c(10, 20, 30, 40),
  y = c(25,  5, 15, 35)
)
```
<br>

Utilisons la fonction `st_as_sf()` avec l'argument `coords`.

```{r}
points_sf <- st_as_sf(point_df, coords = c("x","y"))
points_sf
```
<br>

Nous pouvons également définir un SCR en utilisant l'argument `crs`.
```{r}
points_sf <- st_as_sf(point_df, coords = c("x","y"), crs = 32182)
points_sf
```
<br>


### Lire un shapefile et interpréter sa géométrie {#read_vec}


#### Lire les données {.unnumbered #lire-shp}

Nous allons lire les trois *shapefiles* suivants :

- Des données vectorielles de type polygone représentant la frontière de notre zone d’étude, ici, l'île de Montréal.
- Des données vectorielles de type ligne représentant les pistes cyclables sur l'île de Montréal, et
- Des données vectorielles de type point représentant la position d'accidents impliquant des bicyclettes.


Dans un premier temps, nous allons ouvrir les données vectorielles de type polygone qui contiennent les limites terrestres de l'île de Montréal. Pour lire ces données nous utiliserons la fonction `st_read()` de la bibliothèque `sf`. Pour utiliser `st_read()` nous devons spécifier le chemin menant au fichier *shapefile* à lire.

```{r terre, comment=""}
limites_terrestres <- st_read("Module4/Module4_donnees/Montreal_Velo/terre/terre_shp.shp")
```
<br>

La fonction `st_read()` vous permet d'ores et déjà d'obtenir certaines informations sur la structure des données vectorielles que vous venez de lire: le type de géométrie (`Geometry type`), la dimension des données (`Dimension`), l’étendue spatiale des données (`Bounding box`), et le système de coordonnées projetées (`Projected CRS`). Nous explorerons ces propriétés en détails plus bas.

Nous allons maintenant lire les données vectorielles de type ligne, en utilisant encore la fonction `st_read()`.



```{r pistes, comment=""}
pistes_cyclables <- st_read("Module4/Module4_donnees/Montreal_Velo/pistes/pistes_cyclables_type.shp")
```

<br>

Finalement, nous allons lire les données vectorielles de type point, en utilisant toujours la fonction `st_read()`.



```{r accidents, comment=""}
accidents_velo <- st_read("Module4/Module4_donnees/Montreal_Velo/accidents/accidents2018_Mtl_velo.shp")
```

<br>

Remarquez que le type de géométrie (`Geometry type`) diffère pour les trois classes de données lues comme nous nous y attendions.
<br>

#### Explorer les métadonnées d’un shapefile {-}

Les informations contenues dans un *shapefile* sont appelées des métadonnées. Nous sommes particulièrement intéressées aux métadonnées géospatiales.

Les métadonnées fondamentales d’un *shapefile* sont :

1.	Le type de géométrie : le type de classes des données vectorielles téléchargées.
2.	La projection : le système de coordonnées de référence utilisé pour représenter les données.
3.	L’étendue spatiale : la superficie géographique couvrant les données vectorielles.

##### Le type de géométrie {-}

Nous pouvons explorer chacune de ces métadonnées en utilisant des fonctions de la librairie `sf`. Le type de géométrie est obtenu par la fonction `st_geometry_type()`. Par exemple, pour les limites terrestres de la ville de Montréal, cette fonction nous donne:

```{r type-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, attr.output='style="max-height: 200px;"'}
st_geometry_type(limites_terrestres)
```
<br>

Nous avons ainsi la confirmation que ces données vectorielles correspondent à des polygones (plus exactement, 72 polygones). Les 18 niveaux donnés en dessous constituent une liste des classes possibles de géométrie.

En comparaison, pour les données de type ligne et de type point nous obtenons plutôt :

```{r type-pistes, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, attr.output='style="max-height: 200px;"'}
st_geometry_type(pistes_cyclables)
```
<br>

```{r type-accidents, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, attr.output='style="max-height: 200px;"'}
st_geometry_type(accidents_velo)
```

<br>

Vous remarquez alors que les pistes cyclables sont composées de nombreuses multilignes. Une multiligne étant elle-même un ensemble de lignes.
Quant aux accidents de vélo, ce sont des points qui désignent la position précise des accidents. On en compte 796 en 2018.


##### La projection {-}


Vérifions maintenant la projection des *shapefiles* en utilisant la fonction `st_crs()` de la bibliothèque `sf`. Pour le *shapefile* `limites_terrestres` nous obtenons:

```{r proj-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, attr.output='style="max-height: 200px;"'}
st_crs(limites_terrestres)
```
<br>

La fonction `st_crs()` donne beaucoup d'informations. Pour connaitre la projection utilisée, le datum, le code ESPG, ou l'unité de mesure de la projection nous pouvons préciser la sortie désirée de la fonction, de la manière suivante:
```{r proj-terre-details, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_crs(limites_terrestres)$Name
st_crs(limites_terrestres)$proj4string
st_crs(limites_terrestres)$epsg
st_crs(limites_terrestres)$units
```
<br>

Ainsi, la projection du *shapefile* `pistes_cyclables` est:
```{r proj-pistes, echo = TRUE,  warning = FALSE, message = FALSE, comment="", eval = TRUE}
st_crs(pistes_cyclables)$proj4string
```
<br>

Et la projection du *shapefile* `accidents_velo` est:
```{r proj-accidents, echo = TRUE,  warning = FALSE, message = FALSE, comment="", eval = TRUE}
st_crs(accidents_velo)$proj4string
```
<br>

Les données de tous les *shapefiles* sont dans la projection de Mercator transverse (`+proj=tmerc`) et utilisent le Système de référence géodésique nord-américain de 1983 (`+datum=NAD83`). 
<br>


##### L'étendue spatiale {-}

L’étendue spatiale d’un objet spatial dans `R`, appelée le `Bounding box`, représente les limites géographiques des données, ou la localisation des données les plus au sud, nord, est et ouest. Pour connaître l’étendue spatiale des *shapefiles* nous utilisons la fonction `st_bbox()` de la librairie `sf` :


```{r bbox-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_bbox(limites_terrestres)
```
<br>

```{r bbox-pistes, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_bbox(pistes_cyclables)
```
<br>

```{r bbox-accidents, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_bbox(accidents_velo)
```
<br>


##### Les attributs {-}


Finalement, nous pouvons visualiser toutes les métadonnées et les attributs d'un *shapefile* simplement en écrivant son nom dans la console `R`:
```{r tout-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, attr.output='style="max-height: 200px;"'}
limites_terrestres
```
<br>

```{r tout-pistes, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, attr.output='style="max-height: 200px;"'}
pistes_cyclables
```
<br>

```{r tout-accidents, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, attr.output='style="max-height: 200px;"'}
accidents_velo
```
<br>

### Visualisation de shapefiles sous R

#### Visualisation avec la librairie Mapview {-}

Vous allez maintenant apprendre à visualiser des données *shapefile* en utilisant la fonction `mapview()` de la librairie `mapview`. Cette bibliothèque est une des plus simples à utiliser pour visualiser rapidement des données spatiales. Commençons par charger cette bibliothèque dans la console `R`:

```{r load-mapview}
library(mapview)
```

Dans un premier temps, visualisons les limites terrestres de la ville de Montréal.

```{r plot-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png'}
mapview(limites_terrestres, col.regions = "white")
```
<br>

Remarquez que nous avons choisi la couleur blanche pour représenter l'intérieur des polygones délimitant la ville de Montréal. La couleur par défaut (c-à-d si on ne précise pas de couleur) est bleue.

Passez votre curseur sur la carte ainsi créée et remarquez que vous pouvez cliquer sur chacun des polygones contenus dans cette couche de données.

Remarquez aussi la légende dans le coin supérieur gauche de la carte créée et approchez-y votre curseur. Vous pouvez alors sélectionner une ou l'autre des arrières-plans disponibles. L'option "OpenStreetMap" affichera la carte produite par ce gratuitiel de cartographie pour la région entourant le polygone illustré. L'option "ESRI.WorldImagery", quant à elle, affichera une image satellitaire de la région.


Dans un deuxième temps, visualisons les pistes cyclables. Utilisons toujours la fonction `mapview()` et demandons que la couleur du trait des lignes soit verte foncée. Pour définir la couleur des lignes, nous utilisons l'argument `color` et non l'argument `col.regions`.

```{r plot-velo, warning = FALSE, message = TRUE, dev = 'png', fig.cap = "Pistes cyclables sur l'île de Montréal"}
mapview(pistes_cyclables, color = "darkgreen")
```

<br>

Il existe 657 couleurs prédéfinies dans `R`. Taper la commande `colors()` dans votre console `R` pour voir afficher le nom des couleurs. Celles-sont sont listées par ordre alphabétique sauf pour la première couleur, qui est le blanc (`white`). Ainsi, vous pouvez utiliser une couleur en assignant son nom ou son numéro. Pour produire la figure précédente, `color = "darkgreen"` aurait pu être remplacé par
`color = colors()[81]`. Essayez pour voir.

Pour en apprendre davantage sur les couleurs dans `R`, vous êtes invité à consulter le site [Earl Glynn](https://github.com/EarlGlynn/colorchart/wiki/Color-Chart-in-R) et à conserver dans vos notes son [tableau synthèse des couleurs](Module4/4_TableauCouleurs.pdf) dans `R`. Nous discuterons plus en détails des couleurs dans le [Module 6](#carto) portant sur la cartographie.

Dans la carte des pistes cyclables, remarquez la légende apparue dans le coin supérieur droit. Celle-ci identifie les différentes catégories de pistes cyclables. Cette information correspond aux différentes valeurs que peut prendre l'attribut "TYPE_VOIE" du *shapefile* `pistes_cyclables`. Nous y reviendrons plus bas.


Finalement, visualisons les accidents de la route impliquant des bicyclettes.
```{r plot-accidents, warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.cap="Accidents de la route avec cyclistes sur l'île de Montréal"}
mapview(accidents_velo, color = "red", col.regions = "red", cex = 1, legend = NULL)
```

<br>

La position des accidents est représentée par des points dont le contour et l'intérieur, dénotés par les arguments `color` et `col.regions` respectivement, sont de couleur rouge. 

L'argument `cex`, quant à lui, indique la taille des cercles, la taille par défaut utilisée dans `mapview` est 2. Ici, nous avons demandé une taille plus petite afin de mieux différencier chacun des points.


<br>

#### Visualiser des données vectorielles par attribut {-}

Lorsque nous avons affiché les métadonnées du *shapefile* `pistes_cyclables`, vous avez peut-être observé que ce dernier comprenait l'attribut `TYPE_VOIE` qui caractérise le type de pistes cyclables de chaque multiligne. Affichons les métadonnées à nouveau:
```{r plot-voie0, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', attr.output='style="max-height: 200px;"'}
pistes_cyclables
```
<br>

Utilisons la fonction `factor()` pour convertir la classe de l'attribut `TYPE_VOIE` de charactère (`chr`) à facteur (`Factor`). Puis, utilisons la fonction `levels()` pour connaître ces types de voie cyclables. La fonction `levels` donne les différentes valeurs que peuvent prendre un attribut.

```{r plot-voie1, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
pistes_cyclables$TYPE_VOIE <- factor(pistes_cyclables$TYPE_VOIE)
levels(pistes_cyclables$TYPE_VOIE)
```

<br>

Si vous ne connaissez pas la distinction entre ces types d'aménagement cyclable, consulter ce [document sommaire](Module4/4_Amenagement3Cyclable3Mtl.pdf) de la *Ville de Montréal*^[Ville de Montréal. Aménagements cyclables. Repéré le 19 mars 2020]

Dans la figure précédente illustrant les pistes cyclables, celles-ci étaient illustrées en vert peu importe leur type. Nous voulons maintenant représenter les six types de voie cyclable par six couleurs différentes. Un des avantages de la fonction `mapview()` est qu'elle est capable d'emblée de distinguer les différentes valeurs que peuvent prendre un attribut. Ainsi, nous pouvons simplement demander:

```{r plot-voie2, warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.cap="Bandes cyclables sur l'île de Montréal"}
mapview(pistes_cyclables)
```

<br>

Le *shapefile* `pistes_cyclables` contient un seul attribut, "TYPE_VOIE". Si un *shapefile* contient plus d'un attribut, il faut spécifier celui qu'on veut représenter en argument à la fonction `mapview()`. Dans le cas présent, nous aurions plutôt demandé: `mapview(pistes_cyclables, z = "TYPE_VOIE").

Par défaut, la fonction `mapview()` pour les données vectorielles utilise la palette de couleur *viridis*. Une palette de couleur est un ensemble de plusieurs couleurs prédéfinies et stocké dans un vecteur. Il existe plusieurs palettes de couleur prédéfinies et nous y reviendrons également au [Module 6](#carto) portant sur la cartographie. La palette *viridis* forme un gradient allant du mauve au jaune en passant pas le bleu et le vert (Fig \@ref(fig:plot-viridis)):

<!--   
```{r  echo = FALSE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Palette viridis contenant 200 couleurs différentes"}
library(viridis)
n = 200
image(1:n, 1, as.matrix(1:n), col=viridis(n), axes= FALSE, xlab = "", ylab = "", ylim = c(0.1,0.15), asp  = 1)
```
-->

```{r  plot-viridis, echo = FALSE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', dev = 'png', fig.height=0.2, fig.width = 10, fig.show='hold', fig.align='center', fig.cap="Palette viridis contenant 20 couleurs différentes"}
library(viridis)
library(munsell)
library(colorspace)

# Function
pal <- function(col, border = "light gray", ...)
{ n <- length(col)
  plot(0, 0, type="n", xlim = c(0, 1), ylim = c(0, 1),
       axes = FALSE, xlab = "", ylab = "", ...)
  rect(0:(n-1)/n, 0, 1:n/n, 1, col = col, border = border) }
OP <- par( mar=c(0,0,0,0))
h <- viridis(20)
pal(h)
par(OP)

```

<br>

Un utilisateur de `R` peut utiliser des palettes prédéfinies, ou encore définir les siennes. Par exemple, si nous trouvons que les couleurs de la palette *viridis* ne permettent pas de bien différencier les différents types de piste cyclable, nous pouvons nous-même créer une palette contenant six couleurs (car il y a six valeurs possibles pour cet attribut).

```{r plot-voie3, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
couleurs_voie <- c("black","goldenrod", "cornflowerblue", "darkcyan", "hotpink", "mediumpurple")
```
<br>

Nous pouvons ajouter cet argument à la fonction `mapview()`:

```{r plot-voie4, echo = TRUE, warning = FALSE, message = FALSE, dev = 'png', fig.cap="Types de voie cyclable sur l'île de Montréal"}
mapview(pistes_cyclables, color=couleurs_voie, layer.name = "Types de pistes cyclables", lwd = 1 )
```
<br>


<br>

Remarquez que nous avons changé le titre de la légende en utilisant l'argument `layer.name`, et que nous avons réduit l'épaisseur des lignes en utilisant l'argument `lwd`. 

<br>

#### Visualiser plusieurs shapefiles {-}

Nous allons maintenant représenter les données vectorielles `limites terrestres`, `pistes_cyclables` et `accidents_velo` au sein d'une même figure. Il s'agit de définir individuellement chacune des cartes comme un objet `mapview` et de les additionner en utilisant l'opérateur `+`.

```{r plot-all1, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.cap="Pistes cyclables et position des accidents routiers impliquant des bicyclettes sur l'île de Montréal"}
map_limites_terrestres <- mapview(limites_terrestres, col.regions = "darkgray", legend = NULL)
map_pistes_cyclables <- mapview(pistes_cyclables, color=couleurs_voie, 
                               layer.name = "Types de pistes cyclables", lwd = 1)
map_accidents <- mapview(accidents_velo, color = "red", 
                         col.regions = "red", cex = 1, legend = NULL)

map_limites_terrestres + map_pistes_cyclables + map_accidents
```


<br>

### Reprojection de données vectorielles sous R

Dans cette section vous apprendrez à manipuler le système de coordonnées de référence de données vectorielles. Nous avons vu en début de leçon que les données utilisées sont dans la projection de Mercator transverse (`tmerc`) et utilisent le Système de référence géodésique nord-américan de 1983 (`NAD83`). Par exemple, pour connaître la projection des données `limites_terrestres`, nous avions fait:

```{r proj-terre2, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
st_crs(limites_terrestres)$proj4string
```

<br>

Nous allons maintenant transformer le SCR vers la projection de Robinson (`robin`) et le Système géodésique mondial de 1984 (`WGS84`). Pour se faire nous utilisons la fonction `st_transform()` de la bibliothèque `st`.
```{r reproj-terre, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE}
##limites_terrestres_rob <- st_transform(limites_terrestres,
 ##   CRS("+proj=robin +datum=WGS84"))
limites_terrestres_rob <- st_transform(limites_terrestres, CRS("+proj=robin +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs" ))
```
<br>

Comparons les données transformées avec les données initiales. Pour se faire, nous voulons représenter les deux cartes une à côté de l'autre. La bibliothèque `leafsync` associée à la bibliothèque `leaflet` permet de créer facilement des figures avec des panneaux multiples. Nous discuterons plus en détails de ces bibliothèques dans le [Module 6](#carto) portant sur la cartographie. Installez la bibliothèque `leafsync` si ce n'est pas déjà fait, et chargez-là dans votre session de travail.
```{r load-leaflet, results='hide', eval = FALSE, message = FALSE,  warning = FALSE}
library(leafsync)
```
<br>

Représentons mainteant les deux projections différentes en utilisant la fonction `latticeView()` de la bibliothèque `leafsync`. Puisque cette fonction existe à la fois dans la bibliothèque `leafsync` et dans la bibliothèque `mapview` mais qu'elle est obsolète dans cette dernière, nous devons préciser que nous voulons la fonction latticeView()` de la bibliothèque `leafsync` en utilisant la notation suivante: `leafsync::latticeView`
<!--   ```{r  echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, fig.cap="Limites terrestres de l'île de Montréal selon les projections Mercartor (gauche) et Robinson (droit)"}
map_mercator <- mapview(limites_terrestres, col.regions = "red")
map_robinson <- mapview(limites_terrestres_rob)
leafsync::latticeView(map_mercator,map_robinson, ncol = 2)
```
-->

```{r plot-terre2, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.height=6, fig.show='hold',fig.align='center'}
map_mercator <- mapview(limites_terrestres, legend = FALSE, col.regions = "red")
map_robinson <- mapview(limites_terrestres_rob, legend = FALSE)
Map <- leafsync::latticeView(map_mercator,map_robinson, ncol = 2)
Map
```



<br>

Nous remarquons que les deux cartes sont identiques (outre la couleur)! Comment cela est-ce possible sachant que nous venons de transformer la projection ? Ceci s'explique par le fait que la fonction `mapview()` représente par défaut toutes données spatiales dans la projection Pseudo-Mercator (ou Mercator Web), qui est la projection utilisée par l'application *OpenStreetMap*. Ainsi, la fonction `mapview` calcule elle-même le changement de projection avant de représenter des données spatiales. Pour conserver la projection originale il faut utiliser l'argument `native.crs=TRUE`.

Représentons à nouveau les cartes des limites terrestres de la région de Montréal, cette fois en précisant que nous voulons conserver le CRS d'orgine.
```{r plot-terre3, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.height=6, fig.show='hold',fig.align='center', fig.cap="Limites terrestres de l'île de Montréal selon les projections Web Mercartor (gauche), Mercator (centre) et Robinson (droit)"}
map_web <- mapview(limites_terrestres, col.regions = "red", legend = NULL, layer.name = "Mercator Web")
map_mercator <- mapview(limites_terrestres, col.regions = "yellow", legend = NULL, layer.name = "Mercator", native.crs=TRUE)
map_robinson <- mapview(limites_terrestres_rob, legend = NULL, layer.name = "Robinson", native.crs=TRUE)

Map <- leafsync::latticeView(map_web,map_mercator,map_robinson, ncol = 3)
Map

```

<br>

Remarquez que nous avons utilisé l'argument `ncol` dans la fonction `latticeview` pour spécifier le nombre de colonnes - c-à-d le nombre de panneaux verticaux qu'aura cette image. 

Finalement, pour sauvegarder des données vectorielles, nous utilisons la fonction `st_write()` de la bibliothèque `st`, de la même façon que nous avons utilisé la fonction `st_read()` en début de leçon. Par exemple, sauvons les données `limites_terrestres_rob` que nous venons de créer.

```{r save-terre2, echo = FALSE,  warning = FALSE, message = FALSE, eval = FALSE}
# st_write(nom_objet, nom_fichier)
st_write(limites_terrestres_rob,"Module4/Module4_donnees/Montreal_Velo/terre/terre_rob_shp.shp")
```
 
<br>

### Lire une géodatabase et explorer ses couches {#gdt}

Dans cette section, nous allons explorer les données vectorielles d'une géodatabase du Ministère de l'Éducation et de l'Enseignement supérieur du Québec (MEES).

Ces données se trouvent dans le dossier `Donnees_Ouvertes_MEES.gbd` que vous avez normalement téléchargé au début de la leçon. 

<br>


#### Lire les données {-}

Dans la section portant sur le [format des données vectorielles](##### Format de données vectorielles) du [Module 2](#base), nous avons expliqué qu'une géodatabase est une façon de rassembler et d’organiser des données propres à un sujet dans une unique base de données.

La géodatabase `Donnees_Ouvertes_MEES.gdb` contient plusieurs couches de données vectorielles (*layers*) sur les établissements d'enseignement au Québec.

Pour lire et explorer une géodatabase, on continue à utiliser la bibliothèques `sf`. Chaque couche peut être lue individuellement en utilisant la fonction `st_read()`: `st_read("nom_de_la_geodatabase.gdb", layer = "nom_de_la_couche")`. Il est donc nécessaire de connaître d'abord les noms donnés aux couches composants la géodatabase - information qui nous est, pour l'instant, inconnue.

Pour connaître les couches d'une géodatabase, nous utilisons la fonction `st_layers()`

```{r mees-layers}
couches_mees <- st_layers("Module4/Module4_donnees/Donnees_Ouvertes_MEES.gdb")
couches_mees
```
<br>

Nous observons que la géodatabase contient 18 couches différentes. Nous pouvons connaître le nom donné à chaque couche (`layer_name`), leur géométrie (`geometry_type`), le nombre d'objets vectoriels qu'elles contiennent (`features`), et le nombre d'attributs qu'elles décrivent (`fields`).

Les couches dont le nom commence par `CS_` contiennent des données vectorielles relatives aux centres de services scolaires^[Les centres de services scolaires (qui remplacent les commissions scolaires depuis 2020) ont pour rôle d'épauler les établissements d'enseignement situés sur leur territoire. Pour plus d'informations, consultez le site web du MEES^[https://www.quebec.ca/education/prescolaire-primaire-et-secondaire/gouvernance-scolaire/#c42437]]. Puisque chacun de ces centres couvre un territoire qui leur est propre, ces données sont des multi-polygones.

Les couches dont le nom commence par `PPS_` et `ES_` contiennent des données vectorielles relatives aux établissements d'enseignement primaire, secondaire et supérieure. Puisque chacun de ces établissements est identifié par une paire de coordonnées, ces données sont des points. 

Lisons les données vectorielles de la couche `PPS_Public_Ecole` en utilisant la fonction `st_read()`. 

 ```{r ecoles_pub}
ecoles_pub <- st_read("Module4/Module4_donnees/Donnees_Ouvertes_MEES.gdb", layer = "PPS_Public_Ecole")
```
<br>


Cette couche donne la localisation des 5202 écoles primaires et secondaires publiques de la province ainsi que 28 autres attributs associés à ces établissements. 

Notez le système de coordonnées de référence: le datum WGS84 et la projection Pseudo-Mercator (ou Mercator Web) sont utilisés.

Notez aussi que cette couche de la géodatabase possède la même structure que celle d'un *shapefile*.

Nous pouvons visualiser la position des écoles publiques du Québec en utilisant la fonction `mapview()` de la bibliothèque `mapview`.
```{r plot-ecoles-pub, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.cap="Les écoles publiques du Québec"}
mapview(ecoles_pub)
```
<br>
Nous remarquons qu'il est difficile de visualiser la position des écoles dans la région Sud du Québec car il y a énormément de points.
<br>

#### Explorer les attributs d'une couche {-}

Pour explorer les attributs associés à la couche `ecoles_pub`, commençons d'abord par utiliser la fonction `names()` qui retourne le nom associé à chaque attribut de la couche.


```{r names-ecoles-pub, eval = TRUE, echo = TRUE}
names(ecoles_pub)
```
<br>


Notre première réaction à la lecture de ces noms est qu'ils ne sont pas tous intuitifs!
Examinons les quatre attributs suivants: "NOM_OFFCL_ORGNS", "NOM_MUNCP_GDUNO_IMM", "TYPE_CS", et "SHAPE".

L'attribut "NOM_OFFCL_ORGNS" correspond au nom de chaque école publique. On peut lire les premières entrées de cette liste de noms en utilisant la fonction `head()`:
```{r head-noms-ecoles-pub, eval = TRUE, echo = TRUE}
head(ecoles_pub$NOM_OFFCL_ORGNS)
```
<br>

L'attribut "NOM_MUNCP_GDUNO_IMM" correspond au nom de la municipalité dans laquelle se trouve une école publique. Pour avoir un aperçu des valeurs données, on utilise encore la fonction `head`:
```{r head-villes-ecoles-pub, eval = TRUE, echo = TRUE}
head(ecoles_pub$NOM_MUNCP_GDUNO_IMM)
```
<br>


L'attribut "TYPE_CS" identifie les écoles selon leur appartenance à une commision scolaire francophone, anglophone ou à statut linguistique particulier. 

```{r head-type-ecoles-pub, eval = TRUE, echo = TRUE}
head(ecoles_pub$TYPE_CS)
```
<br>

Il y a trois types de commissions scolaires possibles: Anglo, Franco, et Statut. Il est possible d'obtenir cette information en utilisant la fonction `levels()` précédée de la fonction `as.factor()`:
```{r levels-type-ecoles-pub, eval = TRUE, echo = TRUE}
levels(as.factor(ecoles_pub$TYPE_CS))
```
<br>

Finalement, l'attribut "SHAPE" donne la position géographique de chaque école publique et les métadonnées spatiales associées à cette couche:
```{r head-shape-ecoles-pub, eval = TRUE, echo = TRUE}
head(ecoles_pub$SHAPE)
```
<br>

#### Sélection d'un sous-ensemble de données {-}

Pour simplifier la visualisation de cette couche, nous allons nous concentrer sur les écoles de la municipalité de Montréal.
Pour ce faire, nous créons un nouveau *shapefile* en sélectionnant les données propres à la municipalité de Montréal:
```{r ecoles-pub-Mtl, eval = TRUE, echo = TRUE}
ecoles_pub_Mtl<- ecoles_pub[ecoles_pub$NOM_MUNCP_GDUNO_IMM == "Montréal",]
```
<br>


Interprétons cette ligne de commande: elle utilise l'opérateur logique `==` pour sélectionner les écoles publiques de la municipalité de Montréal, ainsi que tous les autres attributs au sein de la couche `ecoles_pub`.

Visualisons maintenant ce nouveau *shapefile* en utilisant la fonction `mapview()`.
```{r plot-ecoles-pub-mtl, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.cap="Les écoles publiques de la ville de Montréal"}
map_pub_mtl<-mapview(ecoles_pub_Mtl, cex = 2)
map_pub_mtl
```

<br>
Ici, nous avons utilisé l'argument `cex` pour diminuer la taille des points sur la carte (la taille par défaut est 6).
En cliquant sur l'un ou l'autre des points vous obtiendrez l'ensemble des attributs propres à l'école sélectionnée.


Nous pouvons également assigner des couleurs aux données vectorielles en fonction des valeurs d'un de ses attributs. Ceci est possible en utilisant l'argument `zcol` de la fonction `mapview()` et en lui assignant de nom de l'attribut que nous désirons illustrer. Utilisons, par exemple, l'attribut "TYPE_CS" qui indique la langue de la commission scolaire.

```{r plot-ecoles-pub-mtl-cs, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.cap="Les écoles publiques de la ville de Montréal par type de commissions scolaires."}
mapview(ecoles_pub_Mtl, zcol = "TYPE_CS", cex = 2, layer.name = 'Commissions scolaires')
```
<br>

De façon similaire, nous aurions pu représenter les écoles de l'île de Montréal selon le niveau d'enseignement qu'on y dispense. Cette information est donnée par l'attribut "ORDRE_ENS".
```{r plot-ecoles-pub-mtl-ens, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.cap="Les écoles publiques de la ville de Montréal selon le niveau d'enseignement."}
mapview(ecoles_pub_Mtl, zcol = "ORDRE_ENS", cex = 2, layer.name = 'Enseignement')
```


<br>

#### Visualisation de plusieurs couches d'une géodatabse {-}

Nous voulons visualiser d'autres types d'établissement d'enseignement donnés dans la géodatabase du Ministère de l'Éducation et de l'Enseignement supérieur du Québec. Choisissons les écoles privées, les établissements de niveau collégial (e.g. CÉGEP) et les universités. Pour se faire nous utilisons encore la fonction `st_read` en spécifiant le nom de la couche (`layer`) désirée.

```{r autres-institutions}
ecoles_priv <- st_read("Module4/Module4_donnees/Donnees_Ouvertes_MEES.gdb", layer = "PPS_Prive_Etablissement")
college<- st_read("Module4/Module4_donnees/Donnees_Ouvertes_MEES.gdb", layer = "ES_Collegial")
univ <- st_read("Module4/Module4_donnees/Donnees_Ouvertes_MEES.gdb", layer = "ES_Universitaire")
```
<br>


Toujours dans le but de simplifier la visualisation, sélectionnons au sein des couches `ecoles_priv`, `college` et `univ` les établissements situés à Montréal. Attention, pour ces couches le nom de l'attribut associé à la municipalié où se situe les établissements listés est "NOM_MUNCP" et non "NOM_MUNCP_GDUNO_IMM".

```{r autres-institutions-Mtl, eval = TRUE, echo = TRUE}
ecoles_priv_Mtl <- ecoles_priv[ecoles_priv$NOM_MUNCP == "Montréal",] 
college_Mtl <- college[college$NOM_MUNCP == "Montréal",]
univ_Mtl <- univ[univ$NOM_MUNCP == "Montréal",]
```

<br>


Nous pouvons visualiser chacun de ces nouveaux *shapefile* individuellement en utilisant la fonction `mapview()`, mais plus intéressant encore est de les visualiser ensemble au sein d'une même carte. Pour se faire nous créons d'abord des cartes individuelles.

```{r plot-ecoles-each-mtl, echo = TRUE,  warning = FALSE, message = FALSE, dev = 'png', eval = TRUE}
map_priv_mtl <- mapview(ecoles_priv_Mtl, color = "red", col.regions = "red", cex = 2)
map_college_mtl <- mapview(college_Mtl, color = "green", col.regions = "green", cex = 4)
map_univ_mtl <- mapview(univ_Mtl, color = "orange", col.regions = "orange", cex = 6)
```
<br>

Remarquez que nous utilisons différentes tailles de points et différentes couleurs pour bien différencier le type d'institution dans la carte qui les combinera. La couleur du contour du point est donnée par l'argument `color` et celle de l'intérieur du point par l'argument `col.regions`. Nous combinons toutes les couches par une simple addition des cartes individuelles
```{r plot-ecoles-all-mtl, echo = TRUE,  warning = FALSE, message = FALSE, eval = TRUE, dev = 'png', fig.cap="Institutions d'enseignement à Montréal"}
map_pub_mtl + map_priv_mtl + map_college_mtl + map_univ_mtl
```
<br>


Dans le menu du coin supérieur gauche de la carte, remarquez que vous pouvez sélectionner/désélectionner chaque couche selon l'information que vous désirez explorer.

Il serait intéressant de créer une nouvelle géodatabase pour sauvegarder les quatre nouveaux *shapefiles* des institutions d'enseignement à Montréal au sein d'une même structure. Malheureusement `R` peut seulement lire des géodatabases mais ne peut pas sauvegarder ce format qui est propriétaire de ESRI. Ainsi, il faudrait utiliser la fonction `st_write()` pour sauvegarder chacun des *shapefiles* individuellement. 

<br>



## Exercices {#ex_vec}


Dans cette section, vous mettrez en pratique certains concepts vus dans la section [leçon](#vec) de ce module.
Bien que la réponse à chaque question soit disponible, il est **très important** de tenter d'y répondre par vous même!

<br>

### Question 1 {-}

Créer une géométrie simple de type polygone qui a la forme d'un carré de 10 unités de long avec un trou en son centre qui a la forme d'un carré de 4 unités de long. 

<details>
<summary> Réponse</summary>
<p>

Définir deux matrices de coordonnées, une pour le grand et l'autre pour le petit carré.
Les coordonnées exactes peuvent prendre n'importe quelles valeurs du moment que la taille de chaque carré respecte les dimensions demandées.

```{r}
matrice_carre_grand  <- rbind(c(1,1), c(1,11), c(11,11), c(11,1), c(1,1))
matrice_carre_petit <- rbind(c(4,4),c(4,8),c(8,8),c(8,4),c(4,4))
```
<br>

Créer une liste avec ces deux matrices et créer le polygone en utilisant la fonction `st_polygon()`

```{r}
polygone <- st_polygon(list(matrice_carre_grand, matrice_carre_petit))
polygone
```
<br>

Visualiser le polygone pour confirmer votre réponse:

```{r mappoly, dev = 'png', comment = FALSE}
mapview(polygone)
```

<br>
</p>
</details> 

<br>

### Question 2 {-}

**a)** Créer 3 géométries simples de type ligne en utilisant les matrices de coordonnées suivantes:
```{r}
matrice_ligne1 <- rbind(c(1,1), c(2,2), c(3,1), c(4,2), c(5,1), c(6,2), c(7,1))
matrice_ligne2 <- rbind(c(1,5), c(3,3), c(7,5), c(3,5), c(4,4))
matrice_ligne3 <- rbind(c(1,3), c(3,7), c(7,8), c(10,10))
```

<details>
<summary> Réponse</summary>
<p>

Utiliser la fonction `st_lignestring()` pour créer les 3 géométries simples de type ligne.
```{r}
ligne1 <- st_linestring(matrice_ligne1)
ligne2 <- st_linestring(matrice_ligne2)
ligne3 <- st_linestring(matrice_ligne3)
```


<br>
</p>
</details> 

<br>

**b)** Définir une couche de données vectorielles comprenant ces 3 lignes, et lui attribuer la projection Web de Mercator.


<details>
<summary> Réponse</summary>
<p>

Créer d'abord un objet `sfc`, c'est-à-dire une *simple feature column*, en utilisant la fonction `st_sfc()`:

```{r}
lignes <- st_sfc(ligne1, ligne2, ligne3)
```
<br>


Ajouter maintenant le SCR demandé. La projection Web de Mercator possède le code EPSG 3857 (revoir le [Module 3](#code_epsg) pour trouver cette information).

```{r}
lignes <- st_sfc(ligne1, ligne2, ligne3, crs = 3857)
lignes
```


<br>
</p>
</details> 

<br>

**c)** Ajouter deux attributs à cette couche de données. Le premier attribut correspond à un nom de votre choix pour désigner chaque ligne, et le deuxième attribut correspond au nombre d'extrémités dans chaque ligne.

<details>
<summary> Réponse</summary>
<p>

Créer une table d'attribut en utilisant la fonction `data.frame()`.

```{r}
lignes_att <- data.frame(
  nom = c("Zigzag", "Tourbillon", "Tordu"),
  nombre = c(nrow(matrice_ligne1), nrow(matrice_ligne2), nrow(matrice_ligne3))
)
lignes_att
```
<br>

Créer un objet `sf`, c'est-à-dire un *simple feature*, en utilisant la fonction `st_sf()` pour unir la table d'attributs des lignes à leur composante spatiale.
```{r}
lignes_sf <- st_sf(lignes, lignes_att)
lignes_sf
```

<br>
</p>
</details> 

<br>

**d)**  Visualiser cette couche de données vectorielles. Assurez-vous d'avoir une légende identifiant chaque ligne par son nom.


<details>
<summary> Réponse</summary>
<p>

Utiliser la fonction `mapview()` et spécifier que l'argument `z` correspond à l'attribut "nom" de l'objet `lignes_sf`.

```{r maplignes, dev = 'png', comment = FALSE}
mapview(lignes_sf, z="nom", layer.name = "Nom des lignes")
```

<br>
</p>
</details> 

<br>

### Question 3 {-}

Pour cette question, vous utiliserez les données vectorielles décrivant les régions administratives de la Nouvelle-Zélande. Ces données se nomment `nz` et sont disponibles dans la bibliothèque `spData`.

```{r}
library(spData) 
data(nz)
```
<br>


**a)**  Combien d'éléments spatiaux contient la couche `nz` et de quel type de géométrie sont ces éléments ?

<details>
<summary> Réponse</summary>
<p>


Pour répondre à cette question, nous pouvons simplement repérer l'information demandée dans l'affichage général de l'objet `nz`
```{r}
nz
```
<br>

Nous pouvons y lire qu'il y a 16 éléments (*features*) et que la géométrie est de type multipolygone.
Nous pouvons également trouver les réponses en utilisant les deux fonctions spécifiques suivantes:

```{r}
nrow(nz)
```
<br>

Effectivement, `nz` étant un `data.frame`, nous pouvons utilisé les manipulations usuelles pour cette classe d'objet. Chaque élément dans un `data.frame` occupe une rangée. 


```{r}
st_geometry_type(nz)
```
<br>

Cette commande nous confirme que la couche `nz` contient bien des multipolygones. 


<br>
</p>
</details> 

<br>

**b)**  Trouver le nombre d'attributs de `nz` et leur nom.

<details>
<summary> Réponse</summary>
<p>


Pour trouver le nombre d'attributs, nous pouvons nous référer à l'affichage général de `nz` (voir plus haut) qui nous informe que l'objet contient 6 attributs (ou champs, *fields* en anglais).

Nous pouvons également utiliser la fonction `ncol()` qui donne le nombre de colonnes dans le `data.frame`.

```{r}
ncol(nz)
```
<br>

L'objet `nz` contient bel et bien 7 colonnes. Cependant, la dernière colonne correspond à la géométrie de chaque élément de `nz` (qui est en fait, un attribut spatial). Ainsi, le nombre d'attribut est 6.

Pour trouver le nom des attributs, nous pouvons encore s'appuyer sur le fait que `nz` est un `data.frame` et utiliser la fonction `names()`:
```{r}
names(nz)
```
<br>


</p>
</details> 

<br>

**c)**  Trouver le code EPSG, le nom et l'unité de mesure de la projection utilisée.

<details>
<summary> Réponse</summary>
<p>


Ces trois informations se trouvent en utilisant les fonctions suivantes: 

```{r}
st_crs(nz)$epsg
st_crs(nz)$Name
st_crs(nz)$units
```
<br>

La projection utilisée est le New Zealand Transverse Mercator 2000.
NZGD 2000 réfère au datum utilisé, appelé le New Zealand Geodetic Datum. 

<br>
</p>
</details> 

<br>

**d)**  Transformer la projection de `nz` pour la projection conique conforme de Lambert (LCC).

<details>
<summary> Réponse</summary>
<p>


La projection conique conforme de Lambert est donnée par le code EPSG 32198. 
```{r}
nz_lcc <- st_transform(nz, crs = 32198)
```

<br>

Vérifions que notre transformation est correcte.

```{r}
st_crs(nz_lcc)$proj4string
```
<br>
</p>
</details> 

<br>

**e)** Chaque polygone de la couche `nz` correspond à une région. Visualiser la couche `nz` en illustrant chaque région avec une couleur différente.

<details>
<summary> Réponse</summary>
<p>


```{r mapnz, dev = 'png', comment = FALSE}
mapview(nz, zcol = "Name", layer.name = "Régions")
```
<br>
</p>
</details> 

<br>


**f)** Importer le fichier `nz_capitales.cvs` contenu dans le dossier `Module4_donnees`. Ce fichier donne le nom et la localisation des capitales de chaque région de la Nouvelle-Zélande. Créer une carte illustrant les frontières des régions ainsi que la position de leur capitale respective.


<details>
<summary> Réponse</summary>
<p>


Tout d'abord, vous devez importer le fichier `nz_capitales.cvs` dans votre session de travail `R`. Utiliser la fonction de base `read.table()` afin de stocker les coordonnées des capitales dans un object de classe `data.frame`.


```{r capnz}
nz_capitales <- read.table("Module4/Module4_donnees/nz_capitales.csv", header = TRUE, sep = ",")
nz_capitales
```


<br>

Nous observons que les coordonnées sont en format longitude/latitude.

Utiliser la fonction `st_as_sf()` pour transformer cette table de coordonnées en données vectorielles de type points. Puisque les coordonnées sont en format longitude/latitude, nous ne pouvons pas assigner un système de coordonnées projecté cartésien. Utilisons simplement le datum WGS 84 pour définir le SCR. Ce dernier est associé au code EPSG 4326.

```{r}
nz_capitales_points <- st_as_sf(x = nz_capitales, 
                        coords = c("Longitude", "Latitude"),
                        crs = 4126)
```

<br>

Utiliser la fonction `mapview()` pour visualiser les polygones des régions et les points correspondants aux capitales de ces régions.

```{r mapnzcap, dev = 'png', comment=FALSE}
mapview(nz, col.regions = "blue", legend = FALSE) + mapview(nz_capitales_points)
```

<br>

Notez que nous n'avons pas besoin de nous assurer que les deux couches soient dans le même SCR puisque la fonction `mapview()` représente par défaut toutes données spatiales dans la projection Mercator Web.

<br>
</p>
</details> 
<br>
