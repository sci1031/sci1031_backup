# Modèles de données spatiales {#base}



Ce module s’intéresse à la façon dont nous représentons les phénomènes spatiaux se déroulant à la surface de la Terre par des données spatiales. Les objectifs principaux sont de connaître les propriétés des deux types de modèle de données spatiales, les données vectorielles et les données matricielles. 

<br>


###### À la fin de ce module vous saurez: {-}

---

 -	Définir les propriétés principales des données vectorielles.
 -	Reconnaître des formats de fichier de données vectorielles.
 -	Définir les propriétés principales des données matricielles.
 -	Reconnaître des formats de fichier de données matricielles.
 -	Comprendre ce qu’est une structure en couches.

---

À la section [Exercices](#ex_markdown1) vous suivrez la première partie d'une introduction à la bibliothèque `rmarkdown`. La deuxième partie de cette introduction aura lieu dans la section [Exercices du Module 3](#ex_markdown2). 

R Markdown permet de créer des documents dynamiques de formats variés (dont HTML, PDF et Word) qui intègrent des morceaux de code R. Dans le cadre de ce cours, toutes vos évaluations devront être remises dans un fichier R Markdown. Cette section vous permet ainsi de vous familiarisez avec cette bibliothèque. 


## Leçon


Les phénomènes spatiaux sont généralement perçus comme étant soit des entités discrètes avec des frontières bien définies ou encore comme des phénomènes continus qu’on observe de partout mais qui ne possèdent pas de frontières naturelles^[Repris de l'introduction aux données spatiales du site [Spatial Data Science](https://rspatial.org/raster/spatial/2-spatialdata.html).]. Une rivière, une route, un pays, ou une ville sont tous des exemples d’entités spatiales discrètes. D’autre part, l’élévation, la température ou la qualité de l’air sont des exemples de phénomènes continus, appelés aussi des champs spatiaux.

<br>
```{r vectomat, fig.align='left', echo=FALSE, fig.cap="Exemples de données vectorielles et matricielles. Gauche: La carte délimitant les régions administratives du Québec est formée à partir de données vectorielles. Droite: La carte topographique du Québec (source : [https://mern.gouv.qc.ca/repertoire-geographique/carte-relief-quebec/)](https://mern.gouv.qc.ca/repertoire-geographique/carte-relief-quebec/))", out.width = c('50%','50%'), fig.show = 'hold'}
#knitr::include_graphics('Module2/images/2_vecto_vs_mat.png')
a1<-'Module2/images/2_regionsadminQC.png'
a2<-'Module2/images/2_elevationQC.png'
m12 <- c(a1,a2)
knitr::include_graphics(rep(m12),1)
```
<br>

Les entités spatiales (ou objets) sont habituellement représentés par ce qu’on appelle des données vectorielles (« vector data », en anglais), alors que les phénomènes continues sont habituellement représentés par des données matricielles (« raster data », en anglais).  Ces deux modèles sont des façons bien différentes de percevoir et de représenter les phénomènes spatiaux. Nous les décrivons dans les deux sous-sections suivantes.


### Les données vectorielles

##### Définition {-}

Les données vectorielles sont utilisées pour représenter des entités spatiales dont les frontières sont explicites et qui possède une localisation précise et unique. Les données vectorielles sont définies par leur localisation géographique, leur géométrie, et un ou plusieurs attributs.

La **localisation géographique** désigne l’emplacement de l’entité selon un système de coordonnées géographique ou un système de coordonnées projeté. Un système de coordonnées géographique utilise un système en trois dimensions pour donner la position (x,y,z) ou longitude et latitude d’une entité spatiale sur la surface sphérique de la Terre. Un système de coordonnées projeté, donne la position d’une entité spatiale sur une surface plane à deux dimensions. Nous reviendrons sur les systèmes de coordonnées de référence à la section 2.1.3.

La **géométrie** d’une entité spatiale correspond à sa forme (« shape », en anglais). Il existe trois principaux types de géométrie, aussi appelées des classes : les points, les lignes, et les polygones  (Tableau \@ref(fig:geometriesimple)). Ces classes peuvent être combinées pour créer des géométries plus complexes; des multipoints, des multilignes, des multipolygones, etc.

<br>
```{r geometriesimple, fig.align='left', echo=FALSE,fig.cap="Exemple de données vectorielles de géométrie simple. Remarquez que dans le cas d’un polygone, la première et la dernière coordonnées sont les mêmes. Tableau inspiré de Wikipedia (https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry)", out.width = '80%'}
knitr::include_graphics('Module2/images/2_geometriesimple.png')
```
<br>

Les données vectorielles comprennent également des variables additionnelles appelées des **attributs**. Les attributs sont toutes informations permettant de décrire une entité spatiale autres que sa localisation et sa géométrie.

##### Géométrie et topologie {-}

Les **points** sont les données vectorielles les plus simples. Par exemple, un point pourrait représenter l’emplacement d’un restaurant dans une ville. Les attributs associés à ce point pourraient inclure les heures d’ouverture, sa spécialité culinaire, l’échelle de prix de son menu ou d’autres informations.

<br>
```{r multipoints, fig.align='left', echo=FALSE,fig.cap="L’emplacement des stations de vélo en libre partage, *Bixi*, dans un quartier de Montréal correspond à une géométrie multipoints. Source : https://secure.bixi.com/map/.", out.width = '80%'}
knitr::include_graphics('Module2/images/2_multipoints.jpg')
```
<br>

Il est aussi possible de combiner plusieurs points ensemble dans une structure multipoints définie par un attribut unique (Figure \@ref(fig:multipoints)). Par exemple, l’ensemble des restaurants de cuisine vietnamienne dans une ville pourrait être considéré comme une géométrie unique.

La géométrie des **lignes** est plus complexe. Le terme ligne en analyse spatiale n’a pas la même définition que dans le langage usuel. Une ligne désigne un ensemble d’une seule ou de plusieurs polylignes (Figure \@ref(fig:multilignes)). Une polyligne, quant à elle, désigne une séquence de segments de droite reliés entre eux. Ainsi, en analyse spatiale, une seule ligne pourrait représenter le fleuve Saint-Laurent et l’ensemble de ces affluents (rivière des Outaouais, rivière Saint-Maurice, le Fjord du Saguenay, etc.). D’autre part, il serait aussi possible de définir plusieurs lignes – une pour chaque affluent, par exemple.

<br>
```{r multilignes, fig.align='left', echo=FALSE,fig.cap="Le réseau hydrologique du bassin de l’Amazone représente un exemple d’un ensemble de polylignes. Source : Wang et al. 2020.", out.width = '50%'}
knitr::include_graphics('Module2/images/2_multilignes.jpg')
```
<br>

Une ligne est représentée par un ensemble ordonné de coordonnées. Les segments de droite peuvent être calculés ou dessinés sur une carte en connectant ensemble les points. Ainsi, la représentation d’une ligne est semblable à celle d’une structure multipoints. La différence notable est que l’ordre des points est important dans la représentation d’une ligne car il est nécessaire de savoir quels points sont connectés entre eux.

Un réseau – par exemple un réseau routier ou un réseau hydrographique – est une ligne de géométrie particulière comprenant des informations additionnelles comme le débit, la connectivité ou la distance.

Un **polygone** désigne un ensemble de polylignes fermées. La géométrie d’un polygone est très semblable à celle des lignes à l’exception que la dernière paire de coordonnées doit coïncider avec la première paire afin de « fermer » le polygone.

Une particularité des polygones est qu’ils peuvent comprendre des trous. C’est-à-dire qu’un polygone peut être entièrement compris à l’intérieur d’un polygone de plus grande superficie. Ceci est le cas d’une île au sein d’un lac, par exemple. Le polygone formant un îlot permet d’éliminer une partie du polygone qui l’englobe. De plus, alors que l’auto-intersection est permise pour une ligne (c’est-à-dire qu’elle peut se croiser sur elle-même), cette propriété n’est pas valide pour un polygone.

Finalement, plusieurs polygones peuvent être considérés comme formant une géométrie unique ((Figure \@ref(fig:multipolygones))). Par exemple, l’Indonésie est constituée de plusieurs îles. Chaque île peut être représentée par son propre polygone, ou encore l’ensemble des îles peut être représenté par un seul polygone (ou multi-polygones) désignant le pays en entier.

<br>
```{r multipolygones, fig.align='left', echo=FALSE,fig.cap="Les Antilles peuvent être représentées par plusieurs polygones distincts pour chaque île, ou par un seul multipolygone. Source : https://fr.wikipedia.org/wiki/Antilles", out.width = '50%'}
knitr::include_graphics('Module2/images/2_multipolygones.png')
```
<br>

Le modèle vectoriel est très efficace pour représenter la **topologie**. La topologie est une description des relations spatiales qu’ont les entités spatiales entre elles. Par exemple, une analyse de données vectorielles permettra de déterminer précisément si une entité spatiale est adjacente à une autre, si elle y est incluse, ou si elle s’intersecte (Figure \@ref(fig:relationsspatiales)).

<br>
```{r relationsspatiales, fig.align='left', echo=FALSE, fig.cap="Exemples de relations spatiales entre deux entités spatiales : a) adjacence, b) inclusion, et c) intersection.", out.width = '100%'}
knitr::include_graphics('Module2/images/2_relationsspatiales.png')
```
<br>

##### Format de données vectorielles {-}  

Les données vectorielles peuvent être stockées dans une grande variété de formats différents. Ces formats ont évolué et continuent d’évoluer en fonction des besoins et des avancées technologiques. Plusieurs formats ont été développés pour être utilisés avec des logiciels commerciaux mais peuvent être lus et parfois édités par d’autres logiciels.

Peu importe leur format, les données vectorielles sont toujours organisées selon une *base de données relationnelle*. Un identifiant désigne chaque objet spatial et l’associe à une géométrie et à un ou plusieurs attributs (Tableau \@ref(fig:baserelationnelle)).

<br>
```{r baserelationnelle, fig.align='left', echo=FALSE, fig.cap="Exemple d’une base de données relationnelle pour la carte des régions administratives du Québec (Figure \\@ref(fig:vectomat)). Chaque objet vectoriel dans la carte correspond à une ligne dans la base de données où figurent les attributs qui lui sont associés", out.width = c('55%','41%'), fig.show = 'hold'}
a1<-'Module2/images/2_baserelationnelleA.png'
a2<-'Module2/images/2_baserelationnelleB.png'
m12 <- c(a1,a2)
knitr::include_graphics(rep(m12),1)
```
<br>

Voici une liste non-exhaustive de formats de données vectorielles.

###### SHAPEFILE (.SHP, .DBF, .PRJ, .SHX) {-}

  Le *shapefile* est un format propriétaire d’ESRI créé pour les logiciels ArcView et ArcGIS. En français, on le nomme aussi un fichier de forme. À ce jour, il est le format le plus couramment utilisé pour les données vectorielles. Il est devenu un standard tant pour les plateformes commerciales qu’opensource.

  Un *shapefile* comprend entre quatre types de fichiers qui contiennent des informations différentes et toutes essentielles à sa représentation.

  -	.shp : contient les données spatiales
  -	.dbf : contient les données d’attributs
  -	.prj : contient l’information sur la projection des données
  -	.shx : fichier d’index

  Le fichier d’index sert à lier entre elles les informations contenues dans les autres fichiers. Il existe parfois d’autres types de fichier d’index (.sbx, .sbn). Pour visualiser un *shapefile*, il est nécessaire d’avoir tous les fichiers associés (et pas seulement le fichier .shp). Le fichier .prj peut être absent. En son absence, le shapefile peut être lu mais les données ne seront pas projetées adéquatement. Nous reviendrons sur le concept de projection plus tard dans ce module.



###### GEODATABASE (.GDB) {-}

 La géodatabase est le nouveau format propriétaire d’ESRI conçu pour ArcGIS. Il est de plus en plus adopté car il présente de nombreux avantages par rapport au *shapefile*. Une géodatabase est une façon de rassembler et d’organiser des données propres à un sujet ou à un projet dans une unique base de données. Elle peut contenir des données géographiques dans une large gamme de fichiers et de formats (Figure \@ref(fig:geodatabase)).

<br>
```{r geodatabase, fig.align='left', echo=FALSE,fig.cap="Illustration d’une géodatabase telle que représentée sur le site web d’ArcGIS. Image récupérée à : https://desktop.arcgis.com/fr/arcmap/10.3/manage-data/geodatabases/a-quick-tour-of-the-geodatabase.htm", out.width = '50%'}
knitr::include_graphics('Module2/images/2_geodatabase.PNG')
```
<br>

 Par exemple, un projet sur le réseau de transport d’électricité au Québec pourrait nécessiter l’utilisation de plusieurs *shapefiles* (position des centrales, position des pylônes, parcours des câbles, etc.) et aussi plusieurs données matricielles (topographie, végétation, etc.). Ainsi, il s’avère beaucoup plus efficace d’avoir l’ensemble de ces données au sein d’une même base.

 De plus, une géodatabase peut être utilisée par de multiples utilisateurs, ce qui est fort utile pour assurer le partage efficace, la mise à jour, et la cohérence des données géographiques au sein de grandes organisations, comme des entreprises ou des ministères.

 Malheureusement, bien que les géodatabases peuvent être lues avec `R`, elles peuvent seulement être modifiées dans ArcGIS.


###### GEOGRAPHIC JAVASCRIPT OBJECT NOTATION (.GEOJSON, .JSON) {-}

 Le format geoJSON est un format standard ouvert très utilisé en cartographie web. geoJSON est une extension du format JSON pour les données géographiques. Un fichier geoJSON contient les coordonnées des données géospatiales ainsi que d’autres informations sur les attributs. Un seul fichier est nécessaire pour stocker l’ensemble de l’information.


###### GOOGLE KEYHOLE MARKUP LANGUAGE (.KML, .KMZ) {-}

 Ce format est basé sur le langage XML et est optimisé pour les navigateurs de cartographie web comme Google Maps et Google Earth. KMZ est une version compressée d’un fichier KML (KML-Zipped).


###### COVERAGE {-}

 COVERAGE est le format propriétaire d’ESRI, développé pour le logiciel ArcInfo, qui a précédé le format *shapefile*. C’est une autre façon de stockée les données vectorielles qui nécessite plusieurs fichiers. Bien que ce format ne soit plus utilisé lorsque de nouvelles données vectorielles sont conçues, vous pourriez être amenés à rencontrer ce format si vous devez travailler avec des données qui précédent 1990.


###### ARCINFO INTERCHANGE FILE (.EOO) {-}

 C'est le format utilisé pour importer ou exporter des données d’ArcInfo. Il fonctionne comme un fichier zip et permet de partager facilement en un seul fichier les multiples fichiers et dossiers associés au format Coverage. Il permet aussi de transférer des données matricielles de format GRID.


###### MAPINFO INTERCHANGE FILE (.MID, .MIF) {-}

 C'est le format propriétaire de MapInfo, le compétiteur d’Esri. Le format *shapefile* a supplanté le format interchange qui est de moins en moins utilisé. Le fichier MIF contient la localisation géographique et la topologie, et le fichier MID contient les attributs.


###### WEB MAP SERVICE (WMS) {-}

 N’est pas un format de données mais plutôt un protocole de communication qui permet de visualiser des données spatiales qui sont logées sur un serveur. Les organisations gouvernementales ont souvent recours à cette méthode de partage de l’information spatiale car elle permet de s’assurer que les données diffusées sont toujours à jour. L’utilisateur peut jouer avec les paramètres de visualisation mais ne peut pas importer et modifier les données. Notez que ce protocole est utilisé à la fois pour les données vectorielles et les données matricielles.



### Les données matricielles

##### Définition {-}

Les données matricielles représentent la surface terrestre par une grille régulière, communément appelé un *raster*, formée de rectangles de même forme et de même dimension appelés cellules ou pixels (Figure \@ref(fig:raster)). À chaque cellule de la matrice correspond une valeur numérique (ou une valeur manquante) associée à un attribut d’intérêt. On appelle couche (« layer » en anglais) l’information recueillie dans la matrice.

La valeur d’une cellule peut être continue (p. ex. l’élévation - voir Figure \@ref(fig:vectomat)b) ou catégorique (p. ex. le zonage attribué à différents secteurs d’une ville tel que résidentiel, commercial ou industriel). Normalement, la valeur d’une cellule représente la valeur moyenne (ou la valeur prédominante) pour la superficie qu’elle couvre. Cependant, les valeurs sont parfois estimées pour le centre de la cellule.

<br>
```{r raster, fig.align='left', echo=FALSE,fig.cap="Exemple de données matricielles associées à des classes de végétation obtenues à partir d’une image satellitaire. Figure inspirée de NEON neonscience.org/resources/series/introduction-working-raster-data-r", out.width = '100%'}
knitr::include_graphics('Module2/images/2_raster.jpg')
```
<br>

On peut utiliser une base de données relationnelle pour lier la valeur d’un pixel à l’attribut qu’il décrit (Figure  \@ref(fig:rastertable)). Contrairement aux données vectorielles où les polygones peuvent être associés à plusieurs attributs, une couche de données matricielles peut représenter un seul attribut.

<br>
```{r rastertable, fig.align='center', echo=FALSE,fig.cap="Exemple de table relationnelle pour les données vectorielles de la Figure \\@ref(fig:raster). Une valeur numérique est associée à chaque couleur de l’image ainsi qu’à un attribut, ici le type de végétation.", out.width = c('45%','49%'), fig.show = 'hold'}
a1<-'Module2/images/2_raster_tableB.png'
a2<-'Module2/images/2_raster_tableC.png'
m12 <- c(a1,a2)
knitr::include_graphics(rep(m12),1)
```
<br>

Dans leur format le plus simple, les données matricielles prennent la forme d’une image digitale. Cependant, pour associer les données matricielles à une location particulière sur la surface de la Terre, des informations spatiales doivent être ajoutées. Ainsi, un fichier de données matricielles géospatiales débute toujours par une section, appelée le «header» en anglais, qui procure la localisation.

La localisation pour des données matricielles est définie par **l’étendue spatiale** (« extent » en anglais) couverte par la matrice, la **dimension** des cellules, le **nombre de rangées et de colonnes** qui divisent la superficie (respectivement « rows » et « columns » en anglais), et le **système de coordonnées géographique  ou projeté**.  La dimension des cellules correspond à la résolution spatiale et peut être calculée à partir de l’étendue et du nombre de rangées et de colonnes.

##### Résolution et géométrie {-}

La **résolution** définie la précision avec laquelle nous pouvons discerner les objets dans l’espace. Une grande résolution correspond à une matrice de données dont les cellules ont une petite taille (Figure \@ref(fig:resolution)). En conséquence, une telle matrice est plus lente à visualiser et à manipuler, et requière un fichier plus volumineux. En contrepartie, une couche de données matricielles de faible résolution possède des cellules de plus grande taille, se visualise et se manipule plus rapidement, et est contenue dans un fichier moins volumineux.

<br>
```{r resolution, fig.align='left', echo=FALSE,fig.cap="Exemple du concept de résolution: plus la résolution est grande, plus la taille des cellules est petite. Dans cette figure, la résolution diminue de droite à gauche, et la taille des cellules augmente. Source de données: https://mern.gouv.qc.ca/nos-publications/spatiocarte-quebec/", out.width = '100%'}
knitr::include_graphics('Module2/images/2_resolution.jpg')
```
<br>

Contrairement aux données vectorielles, la géométrie des données matricielles n’est pas définie explicitement par un ensemble de coordonnées. La géométrie peut être déduite en observant les démarcations se produisant aux limites des ensembles de cellules de même valeur. Cependant ces démarcations ne correspondent pas nécessairement aux frontières des entités sur le terrain (Figure \@ref(fig:boundary)).

<br>
```{r boundary, fig.align='left', echo=FALSE,fig.cap="La géométrie des objets spatiaux matriciels. Les frontières d’une entité spatiale définie avec des données matricielles (droite) ne correspondent pas nécessairement aux frontières réelles (gauche)", out.width = '80%'}
knitr::include_graphics('Module2/images/2_raster_boundary.png')
```
<br>

Ainsi, lorsque nous représentons des objets spatiaux aux frontières bien définies, l’utilisation de données vectorielles plutôt que matricielles s’avère plus précise et plus efficace.

Par ailleurs, la représentation de phénomènes continus avec des données vectorielles, nécessiterait de définir un grand nombre de petit polygones et d’enregistrer les coordonnées de chacun d’eux. Dans la majorité des cas, une telle représentation augmenterait dramatiquement le temps de traitement des données.

##### Données matricielles à bande unique et multi-bandes {-}

Un *raster* peut contenir une couche ou plusieurs couches de données. Par exemple, un fichier de données matricielles d’élévation comprendra une seule couche de données, soit l’élévation à chaque cellule. Par exemple la carte topographique du Québec (Figure \@ref(fig:vectomat)b) est un exemple de raster à une seule couche.

Un raster à une seule couche peut aussi représenter des images en noir et blanc en utilisant un codage binaire pour exprimer différentes teintes de gris. Un codage sur 1 bit exprimera 2<sup>1</sup> (2) teintes de gris [0,1], un codage sur 4 bit exprimera 2<sup>4</sup> (16) teintes de gris [0,1,2,…,15], et un codage sur 16 bits exprimera 2<sup>16</sup> (65536) teintes de gris [0,1,2,…, 65535] (Figure \@ref(fig:binaire)).

<br>
```{r binaire, fig.align='left', echo=FALSE,fig.cap="Exemple de codage binaire pour les *raster* à une couche: Images en blanc et noir utilisant différentes teintes de gris : 2 teintes (gauche), 8 teintes (centre) et 256 teintes (droite).", out.width = '100%'}
knitr::include_graphics('Module2/images/2_binaire.png')
```
<br>

D’autres rasters peuvent contenir plusieurs couches, appelées aussi des bandes (ou canaux). Par exemple, les images de couleurs contiennent souvent trois bandes: une bande de rouge, une bande de vert et une bande de bleu. C’est ce qu’on nomme le format RGB (pour « red », « green », et « blue »). Ces bandes font références à des sections du spectre électromagnétique captées lors de la prise de l’image (Figure \@ref(fig:electro)).

<br>
```{r electro, fig.align='left', echo=FALSE,fig.cap="*Raster* multibande. Les bandes blues, vertes et rouges correspondent à des sections du spectre électromagnétique. Source: Esri. Image récupérée à https://desktop.arcgis.com/en/arcmap/10.3/manage-data/raster-and-images/raster-bands.htm.", out.width = '50%'}
knitr::include_graphics('Module2/images/2_electromagnetic_spectrum.png')
```
<br>


En combinant ces bandes, on peut recréer l’image (Figure \@ref(fig:3bands)). Attention : chaque bande doit posséder les mêmes informations spatiales pour être superposée aux autres.

<br>
```{r 3bands, fig.align='left', echo=FALSE,fig.cap="Image satellitaire de région de l’Estrie. Le raster multi-bande contient une bande de rouge, une bande de vert et une bande de bleu. L’image couleur s’obtient en combinant les trois bandes.  Source de données: https://mern.gouv.qc.ca/nos-publications/spatiocarte-quebec/", out.width = '100%'}
knitr::include_graphics('Module2/images/2_3bands.jpg')
```
<br>

##### Format des données matricielles {-}

Tout comme les données vectorielles, les données matricielles peuvent être stockées dans une grande variété de formats différents. Les images possèdent des structures matricielles, ainsi les formats bien connus pour la transmission d’images sur le Web, .jpg (Joint Photographic Experts Group), .gif (Graphics Interchange Format), et .png (Portable Network Graphics), sont des exemples de format de données matricielles.

Voici une liste non-exhaustive de formats de données matricielles.

###### GRID (.GRD) {-}

  GRID est le format propriétaire d’ESRI pour stocker des données matricielles.


###### TIFF AND GEOTIFF (.TIF) {-}

  Le Tag Image File format (TIFF) est utilisé pour le stockage d’images numériques. Il a la particularité d’être comme un contenant dans lequel plusieurs informations additionnelles sur les données peuvent être stockées (par ex. les attributs, et autres métadonnées).
Le format GeoTIFF est un fichier .tif standard dans lequel on intègre des informations additionnelles sur la localisation spatiale des données (p. ex. la résolution, l’étendue ou le système de coordonnées).


###### COMMA SEPERATED VALUE FORTMAT (.CSV) {-}

  Le format .csv contient du texte séparé par des virgules, et correspond à une façon simple et très répandue de représenter des données matricielles. Par exemple, un fichier .csv pourrait être constitué de trois colonnes : la première pour la coordonnée x de la cellule, la deuxième pour sa coordonnée y, et la troisième pour la valeur de l’attribut.

  Une autre façon d’utiliser le format .csv est d’y stocker la matrice de données sous forme d’un tableau de dimension égale à cette dernière. Chaque entrée du tableau donne la valeur d’attribut pour la cellule correspondante. Les informations sur la localisation spatiale doivent alors être fournies en en-tête du fichier.


###### BITMAP (.BMP) {-}

  BITMAP est le format d’images utilisé dans les applications de Microsoft Windows.


De plus, comme expliqué plus haut, la géodatabase et Web Map Service sont aussi utilisés pour les données matricielles.


Peu importe le type de données spatiales et le format utilisé pour les stocker, les données spatiales sont souvent accompagnées de **métadonnées**. Les métadonnées sont les données sur les données. C’est-à-dire qu’elles viennent donner des informations supplémentaires pour faciliter la compréhension et l’utilisation des données spatiales (p. ex. l’origine des données, l’auteur.e, les détails sur la structure, le lexique, les abréviations, la légende, etc.). Idéalement, tout ensemble de données devrait être accompagné de métadonnées.


### Structure en couches

Lorsque nous travaillons avec des données spatiales, il est fréquent de devoir combiner des données représentant des phénomènes spatiaux distincts. Nous devons alors utiliser une structure en couches. Une **couche** de donnée réfère à un thème spécifique (par ex. topographie, végétation, ou réseau routier) et contient un seul modèle de données (matricielles ou vectorielles) (Figure \@ref(fig:couches)). 

<br>
```{r couches, fig.align='left', echo=FALSE,fig.cap="Représentation de données spatiales par la superposition de couches thématiques. Source: Esri. Image récupérée à https://desktop.arcgis.com/fr/arcmap/10.3/guide-books/map-projections/what-are-map-projections.htm", out.width = '80%'}
knitr::include_graphics('Module2/images/2_couches.jpg')
```
<br>

La superposition de couches permet de visualiser les relations spatiales entre les données de différentes thématiques [@Auda2018]. Il est primordial que chaque couche de données utilise le même système de coordonnées de référence lorsqu’elles sont superposées. Le [module 3](#SRC) portera spécifiquement sur cette notion.

<br>

## Exercices {#ex_markdown1}


Cette section est une introduction à R Markdown qui passe en revue différents aspects techniques nécessaires à la bonne compréhension et utilisation de la biblothèque `rmarkdown`. 

Cette introduction est divisée en deux parties. Vous ferez la première partie maintenant, au module 2, et la deuxième partie dans le section [Exercices](#ex_markdown2) du module 3. 


La bibliothèque `rmarkdown` permet de créer des documents de formats variés (dont HTML, PDF et Word) avec un contenu R dynamique. C'est-à-dire des documents qui intègrent des morceaux de code R et ce qu'ils génèrent (p. ex. des figures et tableaux). Le code source de ce site web est lui-même un exemple d'application de cette bibliothèque! 

R Markdown n'est pas un outil spécifique à la visualisation de données spatiales. Toutefois, puisqu'il constitue un outil d'édition, de visualisation et de diffusion fort pratique, nous l'utiliserons dans ce cours. En particulier, les évaluations devront être remises dans un fichier R Markdown `.Rmd`.

À la fin de cette introduction vous saurez: 

---

 - Décrire en quoi consiste R Markdown;
 - Décrire les liens entre R, Markdown et Pandoc;
 - Utiliser la syntaxe Pandoc Markdown de base;
 - Créer des documents dynamiques avec la bibliothèque `rmarkdown`. 
 
---

<br>
<br>

> Cette introduction à RMarkdown a été rédigée par Kevin Cazelles, collobateur clé à réalisation de ce cours. Kevin est un chercheur en écologie computationnelle et fervent utilisateur des outils pour la science ouverte. Allez voir ses travaux sur son site  <https://kevcaz.insileco.io/>  et son profil GitHub <https://github.com/KevCaz>.


<br>



### Introduction à R Markdown

#### Bénéfices de R Markdown {-}

Dans de nombreux milieux professionnels, à des fins de communication diverses,
sont produits régulièrement des documents intégrant des analyses de données
(tableaux, figures, tests statistiques, etc.). Pour créer de tels documents, il
faut être en mesure de manipuler des données, de les analyser et de créer des figures
pour les intégrer dans le document final. R est un
langage de programmation qui répond à ces besoins avec un grand nombre de
bibliothèques qui permettent de manipuler et traiter un spectre très large de données
et de les visualiser efficacement. 

Le langage R offre également la possibilité
d'intégrer code et les produits du code (résultats de tests, tableaux, figures,
etc.) directement dans un document qui est alors qualifié de dynamique. La
bibliothèque la plus utilisée pour créer des documents dynamiques est 
`rmarkdown`. En effet, elle permet l'intégration de R dans un document écrit avec Markdown et qui peut
être converti en de nombreux formats de document (dont PDF, Word, HTML). 

<br>

#### Qu'est-ce que Markdown? {-}

Markdown est un langage de balisage
léger. C'est-à-dire un langage dans lequel on peut utiliser des ensembles de
caractères spécifiques (des balises) pour délimiter une zone de texte pour
laquelle un formatage associé (e.g. **text en gras**) est appliqué. 

Markdown est aujourd'hui très répandu sur Internet. La syntaxe originale de Markdown est le
fruit du travail de John Gruber[^wiki_gruber], programmeur, bloggeur et
baladodiffuseur de Philadelphie en collaboration avec Aaron Swartz[^wiki_swartz] (lui même
connu pour avoir participer à la création de [Creative Commons](https://creativecommons.org/) et son tragique
destin qui fut l'objet d'un film). 

Sur le site de John Gruber, "daringfireball",
Markdown est décrit depuis décembre 2004 et on peut même y télécharger la
version 1.0.1 (voir <http://daringfireball.net/projects/markdown>). L'idée de
départ est simple et élégante&nbsp;: produire un langage léger qui simplifie les
balises HTML utilisé par tous les sites Internet. L'idée n'est pas tant de
remplacer le HTML mais plutôt d'en augmenter l'efficacité d'écriture et de fait,
il est beaucoup plus rapide d'écrire en Markdown qui couvre les opérations de
formatage les plus courantes (listes, hyperliens, etc.). Notons qu'il existe
d'autres langages qui répondent aux mêmes objectifs, par exemple
ReStructuredText[^wiki_rst].

Après la publication de Markdown, John Gruber a cessé de travailler sur
Markdown[^blog_badparent] et d'autres développeurs, sans doute séduits par le
langage, ont proposé différentes additions syntaxiques. Il s'agissait surtout de
lever certaines limitations tout en préservant l'esprit d'origine. Ci-dessous,
en voici une liste non exhaustive de différentes variantes Markdown:

 - [GitHub Flavored Markdown (GFM)](https://help.github.com/articles/github-flavored-markdown/)
 - [Kramdown](http://kramdown.gettalong.org/syntax.HTML#math-blocks)
 - [Markdown Extra](https://michelf.ca/projects/php-markdown/extra/)
 - [Multi Markdow](https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#math-support)
 - [Pandoc Markdown](http://pandoc.org/README.HTML#pandocs-markdown)

Depuis 2014, CommonMark (<https://commonmark.org/>) propose
une spécification (norme technique) pour Markdown de plus en plus
utilisée[^goldmark]. Ceci signifie qu'en allant d'un outil à l'autre qui
utilise cette spécification, il n'y a pas de questions à se poser quant à savoir
ce qui marche ou non en terme de syntaxe (un problème parfois frustrant quand on
utilise plusieurs outils qui utilisent différentes syntaxes Markdown), il
suffit de se reporter à la spécification!

<br>

####  Qu'est-ce que Pandoc? {-}

R Markdown (voir <http://rmarkdown.rstudio.com>)[^1] utilise [la variante Markdown de
Pandoc](https://rmarkdown.rstudio.com/lesson-8.html)[^2]. 
Pandoc, comme l'indique son site internet (voir <http://www.pandoc.org>) est un "convertisseur de document universel". 
En une ligne de commande, Pandoc convertit un document d'un format donné en un document d'un autre
format. Par exemple, Pandoc permet de passer d'un fichier `.tex` (LaTeX) à un
fichier `.docx` (Word)! 

La variante Markdown de Pandoc a été pensé pour rester
fidèle à l'esprit originel de Markdown tout en incluant davantage d'éléments communs à différents formats de documents[^pmd]. Ainsi, un fichier R Markdown pourra être converti dans un grand nombre de formats grâce à l’utilisation de Pandoc. 

Dans cette introduction, nous nous concentrerons sur la création de documents en format Word, PDF et
HTML, mais que les possibilités offertes par `rmarkdown` sont plus vastes (voir la section [Ressources](#res_RMarkdown) du cours dédiée à la documentation R Markdown). 




<!--  
Pour rendre le document dynamique, R Markdown ajoute notamment les fonctionnalités de l'excellente
bibliothèque [`knitr`](http://cran.r-project.org/web/packages/knitr/index.html) qui
intègre du code R et ce qu'il produit. Le document dynamique en question pourra
être converti dans un grand nombre de formats grâce à l'utilisation de
[Pandoc](http://www.pandoc.org/installing.html). 
 -->

<br>

### Utiliser un fichier RMarkdown

#### Organisation générale {-}

Un fichier R Markdown, dont l’extension est `.rmd` ou `.Rmd`, un fichier de texte brut qui contient trois types de langage.

1. Un langage de programmation, R. Le fichier peut contentir des blocs de codes R utilisés pour présenter des opérations R, pour les exécuter, et pour afficher leur résultat. Ces blocs commencent et finissent par trois accents graves (*backtick* ou *backquote* en anglais): \` et les trois accents graves ouvrant le bloc sont suivis d'une accolade qui commence par r ou R, par exemple

    ````markdown
    `r ''````{R name, option1, option2}
    # code R à exécuter
    ```
    ````

    ou encore

    ````markdown
    `r ''````{r option1}
    # code R à exécuter
    ```
    ````
    
    Ces blocs de code sont intégrés au document grâce aux fonctionnalités de la bibliothèque `knitr`[^knitr]. 
    
2. Un langage de balisage pour l'écriture du document, la variante syntaxique Pandoc de Markdown. 

3. Un langage de sérialisation, YAML, pour personnaliser la mise en page du ou des documents produits. Il s'agit d'une entête (*Front Matter* en anglais) placée au début du document dans un bloc de trois tirets ( \-\-\- ) qui donne des indications sur les sorties à générer. 

    ````markdown
    ---
    title: "R Notebook"
    output: html_notebook
    ---
    ````
 <br>       

De plus, la variante syntaxique Pandoc de Markdown inclut les symboles mathématiques TeX[^wiki_TeX] pour facilité l'écriture, entre autres, des équations. En un sens c'est un quatrième langage que peut contenir un fichier R Markdown!


Une fois le fichier R Markdown créé, il s'agit d'utiliser la fonction R `render()` pour appeler le fichier. R Markdown générera alors le ou les documents selon le format désiré.  

<br>


#### Installer R Markdown {-}

Commençons par installer la bibliothèque `rmarkdown`:

```{r eval = FALSE}
install.packages('rmarkdown')
```

<br>

Pour la production de document PDF, vous aurez besoin d'installer LaTeX. Si vous n'avez pas déjà LaTeX sur votre ordinateur, installer plutôt la bibliothèque `tinytex`[^tiny]:

```{r eval = FALSE}
install.packages('tinytex')
tinytex::install_tinytex()  # installer TinyTeX
```

<br>

#### Créer un fichier R Markdown {.unnumbered #createmarkdownfile}


Créer un fichier R Markdown, c'est simplement créer un fichier dont l'extension
est `.Rmd` ou `.rmd`, ce qui peut être fait avec n'importe quel éditeur de
texte, ou de code, ou même en ligne de commande[^linux]. Dans R Studio, cela peut se faire en
2 clics, comme illustré dans la marche à suivre ci-dessous. L’intérêt d'utiliser R
Studio pour cette opération est que le fichier ainsi créé contient des
indications relatives à l'utilisation du fichier en question.



- **Première étape** : Utilisez l'icône de création de nouveaux fichiers (symbole + dans un cercle vert), et choissez R Markdown dans le menu vertical
![Première étape.](Module2/images/open_rmd.png)
<br>

- **Deuxième étape** : Choisissez le format de sortie désiré (HTML, PDF ou Word), précisez le titre du document ainsi que votre nom, puis appuyez sur la touche OK.
![Seconde étape.](Module2/images/open_rmd2.png)

<br>

- Un fichier contenant différentes instructions et exemples est généré. Sauvegardez le fichier créé en lui attribuant un nom.
![](Module2/images/open_rmd3.png)

<br>

#### Spécifier les options YAML {-}


L'entête YAML sert à spécifier différentes propriétés des documents à générer à
partir du fichier `.Rmd` (par exemple, le titre, la date, les polices de caractères
utilisées, ajout d'une table des matières, etc.) grâce à des gabarits (*templates* en anglais) utilisés par Pandoc.

Lorsque vous créez un fichier `.Rmd` avec R Studio, une entête YAML est créée par défaut avec les champs: titre, autrice ou auteur, date et format de la sortie. 

````markdown
---
title: "mondoc"
author: "Kevin Cazelles"
date: "30/04/2022"
output: html_document
---
````

<br>

Les champs disponibles dépendent des gabarits utilisés qui sont spécifiques à un format donné, les champs par défaut varient
ainsi d'un format à l'autre. Notez qu'il est possible de créer ses propres gabarits et donc d'ajouter autant de champs que désiré. 

Un champ donné peut contenir une chaîne de caractères, une date, des chiffres ou encore une liste:

```yaml
nomduchamp: [élément1, élément2]
```
<br>

ou encore

```yaml
nomduchamp:
    - élément1
    - élément2
```
<br>

On utilise l'indentation pour signifier la hiérarchie entre les différents éléments. <br>
Les commentaires sont introduits par un "\#".

<br> 

Pour un aperçu assez complet des options YAML utilisables dans un fichier R Markdown, rendez-vous à la dernière page du [guide de
référence](http://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf).


Voici quelques exemples de champs valables pour les sorties HTML, PDF et docx:

* `abstract`: le texte d'un résumé apparaissant au début du document produit. 
* `description` : la description du contenu du fichier. celle-ci n'apparaîtra pas sur le document produit. Utiliser les guillemets pour un texte long ou avec des signes de ponctuation. 

<br>


Pour un document HTML, plusieurs champs additionnels sont utiles:

* `theme`: le thème Bootstrap[^boostrap] à utiliser pour l'apparence du document HTML. Les thèmes disponibles sont: `default`, `bootstrap`, `cerulean`, `cosmo`, `darkly`, `flatly`, `journal`, `lumen`, `paper`, `readable`, `sandstone`, `simplex`, `spacelab`, `united`, et `yeti`. Consultez la page de la bibliothèque [Bootswatch](https://bootswatch.com/3/) pour voir à quoi ces thèmes ressemblent. 



* `highlight`: le style de la coloration syntaxique. Les styles disponibles sont: `default`, `tango`, `pygments`, `kate`, `monochrome`, `espresso`, `zenburn`, `haddock`, `breezedark`, et `textmate`. Vous trouverez [ici](https://www.garrickadenbuie.com/blog/pandoc-syntax-highlighting-examples/) quelques exemples de ces styles. 



* `number_sections`: numéroter ou non les sections.



* `toc`: inclure ou non une table des matières (*table of content* en anglais).
* `toc_depth`: la profondeur de la table, c'est-à-dire, le niveau des titres apparaissant sur la table. 
* `toc_float`: inclure ou non la table des matières en menu vertical visible à gauche sur le document HTML. Ce champ peut également être spécifié par une liste d'options: 
   * `collapsed`: permettre ou non un menu de type accordéon qui se referme et se déploie.
   * `smooth_scroll`: colorer ou non le titre d'une section dans le menu lors de la navigation sur la page.

* `fig_width`: la largeur des figures. 

* `fig_height`: la hauteur des figures.
    
* `fig_caption`: inclure ou non une légende aux figures.


<br>

Pour les documents PDF, les champs suivants peuvent être précisés:

* `fontfamily`: la police de caractère.

* `fontsize`: la taille des caractères.


<br>


#### Éditer le contenu du fichier R Markdown {-}


Le contenu principal d'un fichier R Markdown contient du texte et des blocs de code R.

Le texte doit suivre la syntaxe Pandoc Markdown. Nous détaillerons cette [syntaxe](#pandocmarkdown) dans la deuxième partie de cette introduction à R Markdown, à la section [Exercices](#ex_markdown2) du Module 3.

Les blocs de code R sont ce qui distinguent un fichier R Markdown d'un fichier Markdown. La façon dont le code R est intégré au document final est déterminé par une suite de paramètres. Ces paramètres contrôlent, par exemple, si le code est affiché, si le résultat est affiché, la position d'un graphique produit, etc. 
Nous détaillerons également ces [paramètres](#blocsR) dans la deuxième partie de cette introduction à R Markdown.

Lorsque vous créer un fichier R Markdown dans RStudio, un exemple est donné par défaut. Cet exemple contient du texte selon la syntaxe Pandoc de Markdown et du code R. 

<br>

#### Obtenir le document final {-}


Pour générer le document final à partir du fichier R Markdown, nous utilisons la fonction `render()` de la bibliothèque `rmarkdown`.  
Il s'agit d'appeler le fichier `*.Rmd` en spécifiant le chemin vers son répertoire.

```R
render("chemin/ex_Rmardown.rmd")
```
<br>

Nous pouvons ajouter l'argument `all` pour obtenir tous les documents (PDF, HTML, Word) pour lesquels une spécification YAML existe. 


```R
render("ex_Rmardown.rmd", "all")
```
<br>

Avec RStudio, que nous utilisons dans ce cours, générer le document final peut se faire de façon encore plus simple.
Il s'agit d'appuyer sur le bouton **Knit** en haut à gauche dans le menu horizontal du fichier R Markdown. Vous pouvez aussi choisir le format de la sortie dans le menu déroulant associé au bouton Knit : Knit to PDF, Knit to HTML, ou Knit to Word.



### À vous de jouer ! {#exo2}


#### Question 1 {-}

Suivez la démarche présentée pour créer un fichier R Markdown en choisissant le format de sortie HTML ([rappel](#createmarkdownfile)). Préciser les champs de l'entête YAML selon les indications données. Ne modifier pas le contenu du fichier. Créer le document final.

**a)**  


````markdown
---
title: "Bonjour Markdown!"
author: "Votre nom"
date: "La date"
abstract: "Ce document HTML constitue ma première tentative de modifier l'entête YAML d'un document R Markdown"
description: "Eh bien, je pensais que ça serait plus difficile!"
output: 
  html_document:
    theme: yeti
    highlight: breezedark
---
````
<br>

<details>
<summary> Réponse</summary>
<p>

Vous devriez obtenir un document semblable à [celui-ci](https://github.com/sci1031/sci1031/raw/master/Module2/Question1a.png).  

<br>

</p>
</details>

<br>

**b)** 

````markdown
---
title: "Document HTML produit avec le thème darkly"
author: "Votre nom"
date: "la date"
output:
  html_document:
    theme: darkly
    toc: true
    number_section: true
---
````
<br>

<details>
<summary> Réponse</summary>
<p>

Vous devriez obtenir un document semblable à [celui-ci](https://github.com/sci1031/sci1031/raw/master/Module2/Question1b.png).  

<br>

</p>
</details>

<br>

#### Question 2 {-}

Suivez la démarche présentée pour créer un fichier R Markdown en choisissant le format de sortie PDF ([rappel](#createmarkdownfile)). Préciser les champs de l'entête YAML selon les indications données. Ne modifier pas le contenu du fichier. Créer le document final.

````markdown
---
title: "Mon premier document PDF produit avec R Markdown"
author: "Votre nom"
date: "La date"
abstract: "Résumez toute votre vie depuis votre naissance jusqu'au moment où vous vous êtes incrit dans le cours SCI 1031!"
output: 
  pdf_document:
    fig_width: 3
    fig_height: 3
    toc: true
    number_section: true

---
````
<br>

<details>
<summary> Réponse</summary>
<p>

Vous devriez obtenir un document semblable à [celui-ci](https://github.com/sci1031/sci1031/raw/master/Module2/Question2.pdf).  

<br>

</p>
</details>

<br>


[^wiki_gruber]: <https://en.wikipedia.org/wiki/John_Gruber>, consulté le 28 avril 2022.
[^wiki_swartz]: <https://fr.wikipedia.org/wiki/Aaron_Swartz>, consulté le 28 avril 2022.
[^wiki_rst]: <https://fr.wikipedia.org/wiki/ReStructuredText>, consulté le 28 avril 2022.
[^blog_badparent]: <https://blog.codinghorror.com/responsible-open-source-code-parenting/>, consulté le le 28 avril 2022.
[^goldmark]: Par example Goldmark, <https://github.com/yuin/goldmard>, un parser Markdown écrit en Go et utilisé par Hugo (un générateur de site très populaire), est compatible avec Common Mark.
[^1]: La version 1 n'utilise pas Pandoc.
[^2]: Pandoc est d'ailleurs capable de gérer différentes variantes de Markdown.
[^pmd]: Voir <https://pandoc.org/MANUAL.html#pandocs-markdown>, consulté le 29 avril 2022.
[^knitr]: Voir <https://yihui.org/knitr/)>, consulté le 29 avril 2022.
[^wiki_TeX]: Voir <https://fr.wikibooks.org/wiki/LaTeX/%C3%89crire_des_math%C3%A9matiques>, consulté le 29 avril 2022.
[^tiny]: Voir <https://yihui.org/tinytex/>, consulté le 29 avril 2022.
[^linux]: Par example, si vous travaillez dans un environnement Linux, vous pouvez simplement entrer cette commande dans un terminal: ```
$ echo "---\nauthor: VotreNom \n---" > mondoc.Rmd
```
[^boostrap]: Boostrap est une collection d'outils pour le design de page web. Voir: <https://fr.wikipedia.org/wiki/Bootstrap_(framework))>



